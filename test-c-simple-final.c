
error: undefined variable: set-<compiler>-level
[32m[?7l...         [0m set-<compiler>-level
[?7h[32m[?7lcore/compiler/emit.l:174[0m (set-<compiler>-level self level)
[?7h[32m[?7lcore/compiler/emit.l:173[0m (let ((self (let ((_type_ <compiler>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (set-<compiler>-level self level) (set-<compiler>-param-counter self 0) (set-<compiler>-arg-counter self 0) (set-<compiler>-arg-limit self 0) (set-<compiler>-tmp-counter self 0) (set-<compiler>-tmp-limit self 0) (set-<compiler>-temps self (list)) (set-<compiler>-epilogue self 0) (set-<compiler>-asm self (array)) (set-<compiler>-pc self 0) self)
[?7h[32m[?7lcore/compiler/emit.l:172[0m (lambda (level) (let ((self (let ((_type_ <compiler>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (set-<compiler>-level self level) (set-<compiler>-param-counter self 0) (set-<compiler>-arg-counter self 0) (set-<compiler>-arg-limit self 0) (set-<compiler>-tmp-counter self 0) (set-<compiler>-tmp-limit self 0) (set-<compiler>-temps self (list)) (set-<compiler>-epilogue self 0) (set-<compiler>-asm self (array)) (set-<compiler>-pc self 0) self))
[?7h[32m[?7lcore/compiler/emit.l:172[0m (define compiler (lambda (level) (let ((self (let ((_type_ <compiler>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (set-<compiler>-level self level) (set-<compiler>-param-counter self 0) (set-<compiler>-arg-counter self 0) (set-<compiler>-arg-limit self 0) (set-<compiler>-tmp-counter self 0) (set-<compiler>-tmp-limit self 0) (set-<compiler>-temps self (list)) (set-<compiler>-epilogue self 0) (set-<compiler>-asm self (array)) (set-<compiler>-pc self 0) self)))
[?7h[32m[?7lcore/compiler/emit.l:161[0m (lambda (param) (if (variable? param) (symbol->string (oop-at (%typecheck <variable> param) 0)) (concat-string "_param_" (long->string (>> (oop-at (%typecheck <TI32> param) 0) 2)))) (let () (define <compiler> 23) (define <compiler>-level (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 0)))) (define <compiler>-param-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 1)))) (define <compiler>-arg-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 2)))) (define <compiler>-arg-limit (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 3)))) (define <compiler>-tmp-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 4)))) (define <compiler>-tmp-limit (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 5)))) (define <compiler>-temps (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 6)))) (define <compiler>-epilogue (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 7)))) (define <compiler>-asm (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 8)))) (define <compiler>-pc (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 9)))) (define <compiler>-section (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 10)))) 23) (define compiler (lambda (level) (let ((self (let ((_type_ <compiler>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (set-<compiler>-level self level) (set-<compiler>-param-counter self 0) (set-<compiler>-arg-counter self 0) (set-<compiler>-arg-limit self 0) (set-<compiler>-tmp-counter self 0) (set-<compiler>-tmp-limit self 0) (set-<compiler>-temps self (list)) (set-<compiler>-epilogue self 0) (set-<compiler>-asm self (array)) (set-<compiler>-pc self 0) self))) (define new-param (lambda (comp) (let ((i (<compiler>-param-counter comp))) (let ((t (TI32 i))) (set-<compiler>-param-counter comp (+ i 4)) t)))) (define new-arg (lambda (comp) (let ((i (<compiler>-arg-counter comp))) (let ((t (TI32 i))) (set-<compiler>-arg-counter comp (+ i 4)) t)))) (define free-args (lambda (comp args) (and (< (<compiler>-arg-limit comp) (<compiler>-arg-counter comp)) (set-<compiler>-arg-limit comp (<compiler>-arg-counter comp))) (set-<compiler>-arg-counter comp 0))) (define new-temp (lambda (comp) (let ((i (<compiler>-tmp-counter comp))) (let ((t (TI32 i))) (set-<compiler>-tmp-counter comp (+ i 4)) (and (< (<compiler>-tmp-limit comp) (<compiler>-tmp-counter comp)) (set-<compiler>-tmp-limit comp (<compiler>-tmp-counter comp))) t)))) (define new-temps (lambda (comp count) (let ((temps)) (while (<= 0 (set count (- count 1))) (set temps (cons (new-temp comp) temps))) temps))) (define free-temp (lambda (comp temp) (let ((offset (oop-at (%typecheck <TI32> temp) 0))) (let ((_list_ (<compiler>-temps comp))) (while _list_ (let ((tmp (car _list_))) (if (= offset (oop-at (%typecheck <TI32> tmp) 0)) (let () (set-<compiler>-temps comp (list-remove tmp (<compiler>-temps comp))) (return)))) (set _list_ (cdr _list_)))) (error "COMPILER TEMP " offset " NOT ALLOCATED")))) (define free-temps (lambda (comp temps) (let ((_list_ temps)) (while _list_ (let ((temp (car _list_))) (free-temp comp temp)) (set _list_ (cdr _list_)))))) (define new-arg (lambda (comp) (let ((arg (TI32 (<compiler>-arg-limit comp)))) (set-<compiler>-arg-limit comp (+ 4 (<compiler>-arg-limit comp))) arg))) (define new-args (lambda (comp count) (let ((args)) (while (<= 0 (set count (- count 1))) (set args (cons (new-arg comp) args))) args))) (define free-args (lambda (comp args) (let ((_list_ args)) (while _list_ (let ((arg (car _list_))) (set-<compiler>-arg-limit comp (- (<compiler>-arg-limit comp) 4))) (set _list_ (cdr _list_)))))) (define new-param (lambda (comp) (new-temp comp))) (define temp? (lambda (obj) (= <TI32> (type-of obj)))) (add-method free-temp <compiler> (quote (self any)) (quote (()))) (define new-label (lambda (comp) (LABEL (temp-label-name)))) (define new-epilogue (lambda (comp) (or (<compiler>-epilogue comp) (set-<compiler>-epilogue comp (LABEL (temp-label-name)))))) (add-method do-print <TI32> (quote (self)) (quote ((if (= *emit-backend* (quote c)) (print (c-temp-name self)) (print (<TI32>-offset self) "(%esp)"))))) (let () (let () (let () (define <TEXT> 24) 24) (add-method do-print <TEXT> (quote (self)) (quote ((print "TEXT")))) (define TEXT (let ((_type_ <TEXT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <TEXT>) (lambda (op) (and (= *emit-backend* (quote c)) *c-in-data* (let () (println "};") (println) (set *c-in-data* ())))))) (let () (let () (let () (define <DATA> 25) 25) (add-method do-print <DATA> (quote (self)) (quote ((print "DATA")))) (define DATA (let ((_type_ <DATA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DATA>) (lambda (op) (and (= *emit-backend* (quote c)) (set *c-in-data* 1))))) (let () (let () (let () (define <SECTION> 26) 26) (add-method do-print <SECTION> (quote (self)) (quote ((print "SECTION")))) (define SECTION (let ((_type_ <SECTION>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SECTION> <string>) (lambda (op $1)))) (let () (let () (let () (define <INDIRECT> 27) 27) (add-method do-print <INDIRECT> (quote (self)) (quote ((print "INDIRECT")))) (define INDIRECT (let ((_type_ <INDIRECT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <INDIRECT> <LABEL>) (lambda (op $1)))) (let () (let () (let () (define <GLOBAL> 28) 28) (add-method do-print <GLOBAL> (quote (self)) (quote ((print "GLOBAL")))) (define GLOBAL (let ((_type_ <GLOBAL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GLOBAL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) () (println "\011.globl " $1))))) (let () (let () (let () (define <ALIGN> 29) 29) (add-method do-print <ALIGN> (quote (self)) (quote ((print "ALIGN")))) (define ALIGN (let ((_type_ <ALIGN>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ALIGN> <long>) (lambda (op $1) (if (!= *emit-backend* (quote c)) (println "\011.align " $1))))) (let () (let () (let () (define <LONG> 30) 30) (add-method do-print <LONG> (quote (self)) (quote ((print "LONG")))) (define LONG (let ((_type_ <LONG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LONG> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  LONG(" $1 "),") (println)) (println "\011.long " $1))))) (let () (let () (let () (define <LONG> 31) 31) (add-method do-print <LONG> (quote (self)) (quote ((print "LONG")))) (define LONG (let ((_type_ <LONG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LONG> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  (oop)" $1 ",") (println)) (println "\011.long " $1))))) (let () (let () (let () (define <ASCIZ> 32) 32) (add-method do-print <ASCIZ> (quote (self)) (quote ((print "ASCIZ")))) (define ASCIZ (let ((_type_ <ASCIZ>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ASCIZ> <string>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  ") (dumpln $1) (print ",") (println)) (let () (print "\011.asciz ") (dumpln $1)))))) (let () (let () (let () (define <DEFLABEL> 33) 33) (add-method do-print <DEFLABEL> (quote (self)) (quote ((print "DEFLABEL")))) (define DEFLABEL (let ((_type_ <DEFLABEL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DEFLABEL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (if *c-in-data* (let () (println) (println "static oop " $1 "[] = {")) (println $1 ":")) (println $1 ":"))))) (let () (let () (let () (define <ENTER> 34) 34) (add-method do-print <ENTER> (quote (self)) (quote ((print "ENTER")))) (define ENTER (let ((_type_ <ENTER>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ENTER> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (println "{") (set *c-indent* (+ *c-indent* 1))) (let () (println "\011pushl %ebp") (println "\011movl %esp,%ebp") (println "\011subl $" $1 ",%esp")))))) (let () (let () (let () (define <LEAVE> 35) 35) (add-method do-print <LEAVE> (quote (self)) (quote ((print "LEAVE")))) (define LEAVE (let ((_type_ <LEAVE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LEAVE> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "return _eax;") (set *c-indent* (- *c-indent* 1)) (println "}") (println)) (let () (println "\011addl $" $1 ",%esp") (println "\011leave") (println "\011ret")))))) (let () (let () (let () (define <NEG> 36) 36) (add-method do-print <NEG> (quote (self)) (quote ((print "NEG")))) (define NEG (let ((_type_ <NEG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NEG>) (lambda (op) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(-getLong(_eax));")) (println "\011negl %eax"))))) (let () (let () (let () (define <ADD> 37) 37) (add-method do-print <ADD> (quote (self)) (quote ((print "ADD")))) (define ADD (let ((_type_ <ADD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADD> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) + getLong(" $1 "));")) (println "\011addl " $1 ",%eax"))))) (let () (let () (let () (define <SUB> 38) 38) (add-method do-print <SUB> (quote (self)) (quote ((print "SUB")))) (define SUB (let ((_type_ <SUB>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SUB> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) - getLong(" $1 "));")) (println "\011subl " $1 ",%eax"))))) (let () (let () (let () (define <MUL> 39) 39) (add-method do-print <MUL> (quote (self)) (quote ((print "MUL")))) (define MUL (let ((_type_ <MUL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <MUL> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) * getLong(" $1 "));")) (println "\011mull " $1))))) (let () (let () (let () (define <DIV> 40) 40) (add-method do-print <DIV> (quote (self)) (quote ((print "DIV")))) (define DIV (let ((_type_ <DIV>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DIV> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) / getLong(" $1 "));")) (let () (println "\011movl $0,%edx") (println "\011divl " $1)))))) (let () (let () (let () (define <AND> 41) 41) (add-method do-print <AND> (quote (self)) (quote ((print "AND")))) (define AND (let ((_type_ <AND>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <AND> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) & getLong(" $1 "));")) (println "\011andl " $1 ",%eax"))))) (let () (let () (let () (define <OR> 42) 42) (add-method do-print <OR> (quote (self)) (quote ((print "OR")))) (define OR (let ((_type_ <OR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <OR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) | getLong(" $1 "));")) (println "\011orl " $1 ",%eax"))))) (let () (let () (let () (define <XOR> 43) 43) (add-method do-print <XOR> (quote (self)) (quote ((print "XOR")))) (define XOR (let ((_type_ <XOR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <XOR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) ^ getLong(" $1 "));")) (println "\011xorl " $1 ",%eax"))))) (let () (let () (let () (define <NOT> 44) 44) (add-method do-print <NOT> (quote (self)) (quote ((print "NOT")))) (define NOT (let ((_type_ <NOT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NOT>) (lambda (op) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax == nil) ? s_t : nil;")) (let () (println "\011cmpl $0,%eax") (println "\011sete %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <LT> 45) 45) (add-method do-print <LT> (quote (self)) (quote ((print "LT")))) (define LT (let ((_type_ <LT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) < getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setl %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <LE> 46) 46) (add-method do-print <LE> (quote (self)) (quote ((print "LE")))) (define LE (let ((_type_ <LE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) <= getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setle %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <EQ> 47) 47) (add-method do-print <EQ> (quote (self)) (quote ((print "EQ")))) (define EQ (let ((_type_ <EQ>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <EQ> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax == " $1 ") ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011sete %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <NE> 48) 48) (add-method do-print <NE> (quote (self)) (quote ((print "NE")))) (define NE (let ((_type_ <NE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax != " $1 ") ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setne %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <GE> 49) 49) (add-method do-print <GE> (quote (self)) (quote ((print "GE")))) (define GE (let ((_type_ <GE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) >= getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setge %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <GT> 50) 50) (add-method do-print <GT> (quote (self)) (quote ((print "GT")))) (define GT (let ((_type_ <GT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) > getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setg %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <SLA> 51) 51) (add-method do-print <SLA> (quote (self)) (quote ((print "SLA")))) (define SLA (let ((_type_ <SLA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SLA> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) << getLong(" $1 "));")) (let () (println "\011movl " $1 ",%ecx") (println "\011shll %cl,%eax")))))) (let () (let () (let () (define <SRA> 52) 52) (add-method do-print <SRA> (quote (self)) (quote ((print "SRA")))) (define SRA (let ((_type_ <SRA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SRA> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) >> getLong(" $1 "));")) (let () (println "\011movl " $1 ",%ecx") (println "\011sarl %cl,%eax")))))) (let () (let () (let () (define <BR> 53) 53) (add-method do-print <BR> (quote (self)) (quote ((print "BR")))) (define BR (let ((_type_ <BR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BR> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "goto " $1 ";")) (println "\011jmp " $1))))) (let () (let () (let () (define <BF> 54) 54) (add-method do-print <BF> (quote (self)) (quote ((print "BF")))) (define BF (let ((_type_ <BF>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BF> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "if (_eax == nil) goto " $1 ";")) (let () (println "\011cmpl $0,%eax") (println "\011je " $1)))))) (let () (let () (let () (define <BT> 55) 55) (add-method do-print <BT> (quote (self)) (quote ((print "BT")))) (define BT (let ((_type_ <BT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BT> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "if (_eax != nil) goto " $1 ";")) (let () (println "\011cmpl $0,%eax") (println "\011jne " $1)))))) (let () (let () (let () (define <CALL> 56) 56) (add-method do-print <CALL> (quote (self)) (quote ((print "CALL")))) (define CALL (let ((_type_ <CALL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CALL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (print "_eax = " $1 "(") (println ");")) (println "\011call " $1))))) (let () (let () (let () (define <CALL> 57) 57) (add-method do-print <CALL> (quote (self)) (quote ((print "CALL")))) (define CALL (let ((_type_ <CALL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CALL> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = ((oop (*)())(((struct Expr *)_eax)->imp))();")) (println "\011call *%eax"))))) (let () (let () (let () (define <LOAD> 58) 58) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <LI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(" $1 ");")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 59) 59) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)" $1 ";")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 60) 60) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = " $1 ";")) (println "\011movl " $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 61) 61) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = " $1 ";")) (println "\011movl " $1 ",%eax"))))) (let () (let () (let () (define <STORE> 62) 62) (add-method do-print <STORE> (quote (self)) (quote ((print "STORE")))) (define STORE (let ((_type_ <STORE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <STORE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $1 " = _eax;")) (println "\011movl %eax," $1))))) (let () (let () (let () (define <STORE> 63) 63) (add-method do-print <STORE> (quote (self)) (quote ((print "STORE")))) (define STORE (let ((_type_ <STORE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <STORE> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $1 " = _eax;")) (println "\011movl %eax," $1))))) (let () (let () (let () (define <ADDR> 64) 64) (add-method do-print <ADDR> (quote (self)) (quote ((print "ADDR")))) (define ADDR (let ((_type_ <ADDR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADDR> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)&" $1 ";")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <ADDR> 65) 65) (add-method do-print <ADDR> (quote (self)) (quote ((print "ADDR")))) (define ADDR (let ((_type_ <ADDR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADDR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)&" $1 ";")) (println "\011leal " $1 ",%eax"))))) (let () (let () (let () (define <MOVE> 66) 66) (add-method do-print <MOVE> (quote (self)) (quote ((print "MOVE")))) (define MOVE (let ((_type_ <MOVE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <MOVE> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $2 " = " $1 ";")) (let () (println "\011movl " $1 ",%ecx") (println "\011movl %ecx," $2)))))) (let () (let () (let () (define <COMMENT> 67) 67) (add-method do-print <COMMENT> (quote (self)) (quote ((print "COMMENT")))) (define COMMENT (let ((_type_ <COMMENT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <COMMENT> <pair>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (print "/* ") (apply print $1) (println " */")) (let () (print "## ") (apply println $1)))))) (let () (let () (let () (define <CHR-AT> 68) 68) (add-method do-print <CHR-AT> (quote (self)) (quote ((print "CHR-AT")))) (define CHR-AT (let ((_type_ <CHR-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CHR-AT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(((char*)_eax)[getLong(" $1 ")]);")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx),%ecx") (println "\011xorl %eax,%eax") (println "\011movb (%ecx),%al")))))) (let () (let () (let () (define <SET-CHR-AT> 69) 69) (add-method do-print <SET-CHR-AT> (quote (self)) (quote ((print "SET-CHR-AT")))) (define SET-CHR-AT (let ((_type_ <SET-CHR-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SET-CHR-AT> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "((char*)_eax)[getLong(" $1 ")] = getLong(" $2 ");")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx),%ecx") (println "\011movl " $2 ",%eax") (println "\011movb %al,(%ecx)")))))) (let () (let () (let () (define <OOP-AT> 70) 70) (add-method do-print <OOP-AT> (quote (self)) (quote ((print "OOP-AT")))) (define OOP-AT (let ((_type_ <OOP-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <OOP-AT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = ((oop*)_eax)[getLong(" $1 ")];")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx,4),%ecx") (println "\011movl (%ecx),%eax")))))) (let () (let () (let () (define <SET-OOP-AT> 71) 71) (add-method do-print <SET-OOP-AT> (quote (self)) (quote ((print "SET-OOP-AT")))) (define SET-OOP-AT (let ((_type_ <SET-OOP-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SET-OOP-AT> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "((oop*)_eax)[getLong(" $1 ")] = " $2 ";")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx,4),%ecx") (println "\011movl " $2 ",%eax") (println "\011movl %eax,(%ecx)")))))) (add-method gen-definition <expr> (quote (self name ocomp)) (quote ((if (= *emit-backend* (quote c)) (let* ((main (= (quote main) name)) (defn (<expr>-defn self)) (body (cddr defn)) (comp (compiler (+ 1 (<compiler>-level ocomp)))) (params (map-with gen-param (cadr defn) comp))) (print "static oop " (mangle-label name) "(") (let ((first 1)) (list-do param-name (cadr defn) (and (not first) (print ", ")) (set first ()) (print "oop " (mangle-label param-name)))) (println ")") (println "{") (set *c-indent* 1) (c-indent) (println "oop _eax = nil;") (let ((max-args (<compiler>-arg-limit comp))) (for (i 0 (>> max-args 2)) (c-indent) (println "oop _arg_" i " = nil;"))) (let ((max-temps (<compiler>-tmp-limit comp))) (for (i 0 (>> max-temps 2)) (c-indent) (println "oop " (c-temp-name (TI32 (* i 4))) " = nil;"))) (list-do e body (gen e comp)) (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i))) (and (<compiler>-epilogue comp) (let () (println (<compiler>-epilogue comp) ":") (c-indent))) (println "return _eax;") (set *c-indent* 0) (println "}") (println) (set *c-functions* (cons name *c-functions*)) (or main (let () (println "static oop v_" name " = (oop)" name ";") (set *c-globals* (cons name *c-globals*))))) (let* ((main (= (quote main) name)) (defn (<expr>-defn self)) (body (cddr defn)) (comp (compiler (+ 1 (<compiler>-level ocomp)))) (tnam (if main (LABEL name) (LABEL (temp-label-name)))) (vnam (if main () (LABEL name))) (params (map-with gen-param (cadr defn) comp))) (list-do e body (gen e comp)) (let* ((arg-size (align 16 (<compiler>-arg-limit comp))) (tmp-size (align 16 (+ arg-size (<compiler>-tmp-limit comp)))) (frm-size (align 16 (+ tmp-size 8)))) (map (lambda (tmp) (set (<TI32>-offset tmp) (+ arg-size (<TI32>-offset tmp)))) (<compiler>-temps comp)) (map (lambda (tmp) (set (<TI32>-offset tmp) (+ frm-size (<TI32>-offset tmp)))) params) (emit TEXT) (and main (emit GLOBAL tnam)) (emit DEFLABEL tnam) (emit COMMENT (list "frame " arg-size " " (<compiler>-tmp-limit comp) " " tmp-size " " frm-size)) (emit ENTER (- frm-size 8)) (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i))) (and (<compiler>-epilogue comp) (emit DEFLABEL (<compiler>-epilogue comp))) (emit LEAVE (- frm-size 8))) (or main (let () (gen ocomp DATA) (gen ocomp GLOBAL vnam) (gen ocomp DEFLABEL vnam) (gen ocomp LONG tnam) (gen ocomp TEXT)))))))) (add-method gen-definition <long> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (println "static oop v_" name " = LONG(" self ");") (println)) (let () (gen comp DATA) (gen comp DEFLABEL (LABEL name)) (gen comp LONG self) (gen comp TEXT)))))) (add-method gen-definition <string> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (print "static wchar_t " name "_data[] = L") (dumpln self) (println ";") (println "static oop v_" name " = (oop)" name "_data;") (println)) (let ((temp (LABEL (temp-label-name)))) (gen comp DATA) (gen comp DEFLABEL temp) (gen comp ASCIZ self) (gen comp ALIGN 4) (gen comp DEFLABEL (LABEL name)) (gen comp LONG temp) (gen comp TEXT)))))) (add-method gen-definition <extern> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (println "extern oop " (<extern>-name self) "();") (println "static oop v_" (concat-symbol (<extern>-name self) (quote $stub)) " = (oop)" (<extern>-name self) ";") (println)) (let ((nlabel (LABEL self.name)) (slabel (LABEL (concat-symbol self.name (quote $stub))))) (if (defined? (quote __MACH__)) (let () (gen comp SECTION "__IMPORT,__pointers,non_lazy_symbol_pointers") (gen comp DEFLABEL slabel) (gen comp INDIRECT nlabel) (gen comp LONG 0) (gen comp TEXT)) (gen comp DATA) (gen comp DEFLABEL slabel) (gen comp LONG nlabel) (gen comp TEXT))))))) (add-method gen-definition <form> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (println "/* form " name " */") (gen comp COMMENT (list "form " name)))))) (define gen-env-c (lambda (env) (println "// Generated by Maru emit-c backend") (println) (println "#include <stddef.h>") (println "#include <stdio.h>") (println "#include <stdlib.h>") (println "#include <string.h>") (println) (println "// Type definitions") (println "typedef union Object *oop;") (println) (println "// Runtime support") (println "#define nil ((oop)0)") (println "#define LONG(n) ((oop)(((long)(n) << 1) | 1))") (println "#define getLong(x) ((long)(x) >> 1)") (println) (println "// Global symbols") (println "static oop s_t = (oop)1;  // true value") (println) (println "// Forward declarations") (let ((vars (oop-at (%typecheck <env> env) 3))) (let ((index (array-length vars))) (while (<= 0 (set index (- index 1))) (let ((name (oop-at (%typecheck <variable> (array-at vars index)) 0)) (value (oop-at (%typecheck <variable> (array-at vars index)) 1))) (and (= <expr> (type-of value)) (println "static oop " name "(oop);")))))) (println) (println "// Function definitions") (let ((vars (oop-at (%typecheck <env> env) 3))) (let ((comp (compiler 0))) (let ((index (array-length vars))) (while (<= 0 (set index (- index 1))) (let ((name (oop-at (%typecheck <variable> (array-at vars index)) 0)) (value (oop-at (%typecheck <variable> (array-at vars index)) 1))) (gen-definition value name comp)))))) (and (member? (quote main) *c-functions*) (let () (println "// Main entry point") (println "int main(int argc, char *argv[])") (println "{") (println "  oop result = main();") (println "  if (result != nil) {") (println "    printf(\"%ld\\n\", getLong(result));") (println "  }") (println "  return 0;") (println "}") (println))))))
[?7h[32m[?7lcore/compiler/emit.l:161[0m (define c-param-name (lambda (param) (if (variable? param) (symbol->string (oop-at (%typecheck <variable> param) 0)) (concat-string "_param_" (long->string (>> (oop-at (%typecheck <TI32> param) 0) 2)))) (let () (define <compiler> 23) (define <compiler>-level (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 0)))) (define <compiler>-param-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 1)))) (define <compiler>-arg-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 2)))) (define <compiler>-arg-limit (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 3)))) (define <compiler>-tmp-counter (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 4)))) (define <compiler>-tmp-limit (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 5)))) (define <compiler>-temps (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 6)))) (define <compiler>-epilogue (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 7)))) (define <compiler>-asm (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 8)))) (define <compiler>-pc (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 9)))) (define <compiler>-section (form (lambda (*env* self) (list (quote oop-at) (list (quote %typecheck) (quote <compiler>) self) 10)))) 23) (define compiler (lambda (level) (let ((self (let ((_type_ <compiler>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (set-<compiler>-level self level) (set-<compiler>-param-counter self 0) (set-<compiler>-arg-counter self 0) (set-<compiler>-arg-limit self 0) (set-<compiler>-tmp-counter self 0) (set-<compiler>-tmp-limit self 0) (set-<compiler>-temps self (list)) (set-<compiler>-epilogue self 0) (set-<compiler>-asm self (array)) (set-<compiler>-pc self 0) self))) (define new-param (lambda (comp) (let ((i (<compiler>-param-counter comp))) (let ((t (TI32 i))) (set-<compiler>-param-counter comp (+ i 4)) t)))) (define new-arg (lambda (comp) (let ((i (<compiler>-arg-counter comp))) (let ((t (TI32 i))) (set-<compiler>-arg-counter comp (+ i 4)) t)))) (define free-args (lambda (comp args) (and (< (<compiler>-arg-limit comp) (<compiler>-arg-counter comp)) (set-<compiler>-arg-limit comp (<compiler>-arg-counter comp))) (set-<compiler>-arg-counter comp 0))) (define new-temp (lambda (comp) (let ((i (<compiler>-tmp-counter comp))) (let ((t (TI32 i))) (set-<compiler>-tmp-counter comp (+ i 4)) (and (< (<compiler>-tmp-limit comp) (<compiler>-tmp-counter comp)) (set-<compiler>-tmp-limit comp (<compiler>-tmp-counter comp))) t)))) (define new-temps (lambda (comp count) (let ((temps)) (while (<= 0 (set count (- count 1))) (set temps (cons (new-temp comp) temps))) temps))) (define free-temp (lambda (comp temp) (let ((offset (oop-at (%typecheck <TI32> temp) 0))) (let ((_list_ (<compiler>-temps comp))) (while _list_ (let ((tmp (car _list_))) (if (= offset (oop-at (%typecheck <TI32> tmp) 0)) (let () (set-<compiler>-temps comp (list-remove tmp (<compiler>-temps comp))) (return)))) (set _list_ (cdr _list_)))) (error "COMPILER TEMP " offset " NOT ALLOCATED")))) (define free-temps (lambda (comp temps) (let ((_list_ temps)) (while _list_ (let ((temp (car _list_))) (free-temp comp temp)) (set _list_ (cdr _list_)))))) (define new-arg (lambda (comp) (let ((arg (TI32 (<compiler>-arg-limit comp)))) (set-<compiler>-arg-limit comp (+ 4 (<compiler>-arg-limit comp))) arg))) (define new-args (lambda (comp count) (let ((args)) (while (<= 0 (set count (- count 1))) (set args (cons (new-arg comp) args))) args))) (define free-args (lambda (comp args) (let ((_list_ args)) (while _list_ (let ((arg (car _list_))) (set-<compiler>-arg-limit comp (- (<compiler>-arg-limit comp) 4))) (set _list_ (cdr _list_)))))) (define new-param (lambda (comp) (new-temp comp))) (define temp? (lambda (obj) (= <TI32> (type-of obj)))) (add-method free-temp <compiler> (quote (self any)) (quote (()))) (define new-label (lambda (comp) (LABEL (temp-label-name)))) (define new-epilogue (lambda (comp) (or (<compiler>-epilogue comp) (set-<compiler>-epilogue comp (LABEL (temp-label-name)))))) (add-method do-print <TI32> (quote (self)) (quote ((if (= *emit-backend* (quote c)) (print (c-temp-name self)) (print (<TI32>-offset self) "(%esp)"))))) (let () (let () (let () (define <TEXT> 24) 24) (add-method do-print <TEXT> (quote (self)) (quote ((print "TEXT")))) (define TEXT (let ((_type_ <TEXT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <TEXT>) (lambda (op) (and (= *emit-backend* (quote c)) *c-in-data* (let () (println "};") (println) (set *c-in-data* ())))))) (let () (let () (let () (define <DATA> 25) 25) (add-method do-print <DATA> (quote (self)) (quote ((print "DATA")))) (define DATA (let ((_type_ <DATA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DATA>) (lambda (op) (and (= *emit-backend* (quote c)) (set *c-in-data* 1))))) (let () (let () (let () (define <SECTION> 26) 26) (add-method do-print <SECTION> (quote (self)) (quote ((print "SECTION")))) (define SECTION (let ((_type_ <SECTION>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SECTION> <string>) (lambda (op $1)))) (let () (let () (let () (define <INDIRECT> 27) 27) (add-method do-print <INDIRECT> (quote (self)) (quote ((print "INDIRECT")))) (define INDIRECT (let ((_type_ <INDIRECT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <INDIRECT> <LABEL>) (lambda (op $1)))) (let () (let () (let () (define <GLOBAL> 28) 28) (add-method do-print <GLOBAL> (quote (self)) (quote ((print "GLOBAL")))) (define GLOBAL (let ((_type_ <GLOBAL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GLOBAL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) () (println "\011.globl " $1))))) (let () (let () (let () (define <ALIGN> 29) 29) (add-method do-print <ALIGN> (quote (self)) (quote ((print "ALIGN")))) (define ALIGN (let ((_type_ <ALIGN>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ALIGN> <long>) (lambda (op $1) (if (!= *emit-backend* (quote c)) (println "\011.align " $1))))) (let () (let () (let () (define <LONG> 30) 30) (add-method do-print <LONG> (quote (self)) (quote ((print "LONG")))) (define LONG (let ((_type_ <LONG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LONG> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  LONG(" $1 "),") (println)) (println "\011.long " $1))))) (let () (let () (let () (define <LONG> 31) 31) (add-method do-print <LONG> (quote (self)) (quote ((print "LONG")))) (define LONG (let ((_type_ <LONG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LONG> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  (oop)" $1 ",") (println)) (println "\011.long " $1))))) (let () (let () (let () (define <ASCIZ> 32) 32) (add-method do-print <ASCIZ> (quote (self)) (quote ((print "ASCIZ")))) (define ASCIZ (let ((_type_ <ASCIZ>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ASCIZ> <string>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (print "  ") (dumpln $1) (print ",") (println)) (let () (print "\011.asciz ") (dumpln $1)))))) (let () (let () (let () (define <DEFLABEL> 33) 33) (add-method do-print <DEFLABEL> (quote (self)) (quote ((print "DEFLABEL")))) (define DEFLABEL (let ((_type_ <DEFLABEL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DEFLABEL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (if *c-in-data* (let () (println) (println "static oop " $1 "[] = {")) (println $1 ":")) (println $1 ":"))))) (let () (let () (let () (define <ENTER> 34) 34) (add-method do-print <ENTER> (quote (self)) (quote ((print "ENTER")))) (define ENTER (let ((_type_ <ENTER>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ENTER> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (println "{") (set *c-indent* (+ *c-indent* 1))) (let () (println "\011pushl %ebp") (println "\011movl %esp,%ebp") (println "\011subl $" $1 ",%esp")))))) (let () (let () (let () (define <LEAVE> 35) 35) (add-method do-print <LEAVE> (quote (self)) (quote ((print "LEAVE")))) (define LEAVE (let ((_type_ <LEAVE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LEAVE> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "return _eax;") (set *c-indent* (- *c-indent* 1)) (println "}") (println)) (let () (println "\011addl $" $1 ",%esp") (println "\011leave") (println "\011ret")))))) (let () (let () (let () (define <NEG> 36) 36) (add-method do-print <NEG> (quote (self)) (quote ((print "NEG")))) (define NEG (let ((_type_ <NEG>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NEG>) (lambda (op) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(-getLong(_eax));")) (println "\011negl %eax"))))) (let () (let () (let () (define <ADD> 37) 37) (add-method do-print <ADD> (quote (self)) (quote ((print "ADD")))) (define ADD (let ((_type_ <ADD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADD> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) + getLong(" $1 "));")) (println "\011addl " $1 ",%eax"))))) (let () (let () (let () (define <SUB> 38) 38) (add-method do-print <SUB> (quote (self)) (quote ((print "SUB")))) (define SUB (let ((_type_ <SUB>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SUB> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) - getLong(" $1 "));")) (println "\011subl " $1 ",%eax"))))) (let () (let () (let () (define <MUL> 39) 39) (add-method do-print <MUL> (quote (self)) (quote ((print "MUL")))) (define MUL (let ((_type_ <MUL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <MUL> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) * getLong(" $1 "));")) (println "\011mull " $1))))) (let () (let () (let () (define <DIV> 40) 40) (add-method do-print <DIV> (quote (self)) (quote ((print "DIV")))) (define DIV (let ((_type_ <DIV>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <DIV> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) / getLong(" $1 "));")) (let () (println "\011movl $0,%edx") (println "\011divl " $1)))))) (let () (let () (let () (define <AND> 41) 41) (add-method do-print <AND> (quote (self)) (quote ((print "AND")))) (define AND (let ((_type_ <AND>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <AND> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) & getLong(" $1 "));")) (println "\011andl " $1 ",%eax"))))) (let () (let () (let () (define <OR> 42) 42) (add-method do-print <OR> (quote (self)) (quote ((print "OR")))) (define OR (let ((_type_ <OR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <OR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) | getLong(" $1 "));")) (println "\011orl " $1 ",%eax"))))) (let () (let () (let () (define <XOR> 43) 43) (add-method do-print <XOR> (quote (self)) (quote ((print "XOR")))) (define XOR (let ((_type_ <XOR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <XOR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) ^ getLong(" $1 "));")) (println "\011xorl " $1 ",%eax"))))) (let () (let () (let () (define <NOT> 44) 44) (add-method do-print <NOT> (quote (self)) (quote ((print "NOT")))) (define NOT (let ((_type_ <NOT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NOT>) (lambda (op) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax == nil) ? s_t : nil;")) (let () (println "\011cmpl $0,%eax") (println "\011sete %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <LT> 45) 45) (add-method do-print <LT> (quote (self)) (quote ((print "LT")))) (define LT (let ((_type_ <LT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) < getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setl %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <LE> 46) 46) (add-method do-print <LE> (quote (self)) (quote ((print "LE")))) (define LE (let ((_type_ <LE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) <= getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setle %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <EQ> 47) 47) (add-method do-print <EQ> (quote (self)) (quote ((print "EQ")))) (define EQ (let ((_type_ <EQ>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <EQ> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax == " $1 ") ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011sete %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <NE> 48) 48) (add-method do-print <NE> (quote (self)) (quote ((print "NE")))) (define NE (let ((_type_ <NE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <NE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (_eax != " $1 ") ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setne %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <GE> 49) 49) (add-method do-print <GE> (quote (self)) (quote ((print "GE")))) (define GE (let ((_type_ <GE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) >= getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setge %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <GT> 50) 50) (add-method do-print <GT> (quote (self)) (quote ((print "GT")))) (define GT (let ((_type_ <GT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <GT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (getLong(_eax) > getLong(" $1 ")) ? s_t : nil;")) (let () (println "\011cmpl " $1 ",%eax") (println "\011setg %al") (println "\011movzbl %al,%eax")))))) (let () (let () (let () (define <SLA> 51) 51) (add-method do-print <SLA> (quote (self)) (quote ((print "SLA")))) (define SLA (let ((_type_ <SLA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SLA> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) << getLong(" $1 "));")) (let () (println "\011movl " $1 ",%ecx") (println "\011shll %cl,%eax")))))) (let () (let () (let () (define <SRA> 52) 52) (add-method do-print <SRA> (quote (self)) (quote ((print "SRA")))) (define SRA (let ((_type_ <SRA>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SRA> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(getLong(_eax) >> getLong(" $1 "));")) (let () (println "\011movl " $1 ",%ecx") (println "\011sarl %cl,%eax")))))) (let () (let () (let () (define <BR> 53) 53) (add-method do-print <BR> (quote (self)) (quote ((print "BR")))) (define BR (let ((_type_ <BR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BR> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "goto " $1 ";")) (println "\011jmp " $1))))) (let () (let () (let () (define <BF> 54) 54) (add-method do-print <BF> (quote (self)) (quote ((print "BF")))) (define BF (let ((_type_ <BF>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BF> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "if (_eax == nil) goto " $1 ";")) (let () (println "\011cmpl $0,%eax") (println "\011je " $1)))))) (let () (let () (let () (define <BT> 55) 55) (add-method do-print <BT> (quote (self)) (quote ((print "BT")))) (define BT (let ((_type_ <BT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <BT> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "if (_eax != nil) goto " $1 ";")) (let () (println "\011cmpl $0,%eax") (println "\011jne " $1)))))) (let () (let () (let () (define <CALL> 56) 56) (add-method do-print <CALL> (quote (self)) (quote ((print "CALL")))) (define CALL (let ((_type_ <CALL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CALL> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (print "_eax = " $1 "(") (println ");")) (println "\011call " $1))))) (let () (let () (let () (define <CALL> 57) 57) (add-method do-print <CALL> (quote (self)) (quote ((print "CALL")))) (define CALL (let ((_type_ <CALL>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CALL> <long>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = ((oop (*)())(((struct Expr *)_eax)->imp))();")) (println "\011call *%eax"))))) (let () (let () (let () (define <LOAD> 58) 58) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <LI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(" $1 ");")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 59) 59) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <LABEL>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)" $1 ";")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 60) 60) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = " $1 ";")) (println "\011movl " $1 ",%eax"))))) (let () (let () (let () (define <LOAD> 61) 61) (add-method do-print <LOAD> (quote (self)) (quote ((print "LOAD")))) (define LOAD (let ((_type_ <LOAD>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <LOAD> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = " $1 ";")) (println "\011movl " $1 ",%eax"))))) (let () (let () (let () (define <STORE> 62) 62) (add-method do-print <STORE> (quote (self)) (quote ((print "STORE")))) (define STORE (let ((_type_ <STORE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <STORE> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $1 " = _eax;")) (println "\011movl %eax," $1))))) (let () (let () (let () (define <STORE> 63) 63) (add-method do-print <STORE> (quote (self)) (quote ((print "STORE")))) (define STORE (let ((_type_ <STORE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <STORE> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $1 " = _eax;")) (println "\011movl %eax," $1))))) (let () (let () (let () (define <ADDR> 64) 64) (add-method do-print <ADDR> (quote (self)) (quote ((print "ADDR")))) (define ADDR (let ((_type_ <ADDR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADDR> <GI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)&" $1 ";")) (println "\011movl $" $1 ",%eax"))))) (let () (let () (let () (define <ADDR> 65) 65) (add-method do-print <ADDR> (quote (self)) (quote ((print "ADDR")))) (define ADDR (let ((_type_ <ADDR>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <ADDR> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = (oop)&" $1 ";")) (println "\011leal " $1 ",%eax"))))) (let () (let () (let () (define <MOVE> 66) 66) (add-method do-print <MOVE> (quote (self)) (quote ((print "MOVE")))) (define MOVE (let ((_type_ <MOVE>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <MOVE> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println $2 " = " $1 ";")) (let () (println "\011movl " $1 ",%ecx") (println "\011movl %ecx," $2)))))) (let () (let () (let () (define <COMMENT> 67) 67) (add-method do-print <COMMENT> (quote (self)) (quote ((print "COMMENT")))) (define COMMENT (let ((_type_ <COMMENT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <COMMENT> <pair>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (print "/* ") (apply print $1) (println " */")) (let () (print "## ") (apply println $1)))))) (let () (let () (let () (define <CHR-AT> 68) 68) (add-method do-print <CHR-AT> (quote (self)) (quote ((print "CHR-AT")))) (define CHR-AT (let ((_type_ <CHR-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <CHR-AT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = LONG(((char*)_eax)[getLong(" $1 ")]);")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx),%ecx") (println "\011xorl %eax,%eax") (println "\011movb (%ecx),%al")))))) (let () (let () (let () (define <SET-CHR-AT> 69) 69) (add-method do-print <SET-CHR-AT> (quote (self)) (quote ((print "SET-CHR-AT")))) (define SET-CHR-AT (let ((_type_ <SET-CHR-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SET-CHR-AT> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "((char*)_eax)[getLong(" $1 ")] = getLong(" $2 ");")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx),%ecx") (println "\011movl " $2 ",%eax") (println "\011movb %al,(%ecx)")))))) (let () (let () (let () (define <OOP-AT> 70) 70) (add-method do-print <OOP-AT> (quote (self)) (quote ((print "OOP-AT")))) (define OOP-AT (let ((_type_ <OOP-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <OOP-AT> <TI32>) (lambda (op $1) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "_eax = ((oop*)_eax)[getLong(" $1 ")];")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx,4),%ecx") (println "\011movl (%ecx),%eax")))))) (let () (let () (let () (define <SET-OOP-AT> 71) 71) (add-method do-print <SET-OOP-AT> (quote (self)) (quote ((print "SET-OOP-AT")))) (define SET-OOP-AT (let ((_type_ <SET-OOP-AT>)) (let ((_self_ (allocate _type_ (array-at %structure-sizes _type_)))) _self_)))) (%add-multimethod emit (list <SET-OOP-AT> <TI32> <TI32>) (lambda (op $1 $2) (if (= *emit-backend* (quote c)) (let () (c-indent) (println "((oop*)_eax)[getLong(" $1 ")] = " $2 ";")) (let () (println "\011movl " $1 ",%ecx") (println "\011leal (%eax,%ecx,4),%ecx") (println "\011movl " $2 ",%eax") (println "\011movl %eax,(%ecx)")))))) (add-method gen-definition <expr> (quote (self name ocomp)) (quote ((if (= *emit-backend* (quote c)) (let* ((main (= (quote main) name)) (defn (<expr>-defn self)) (body (cddr defn)) (comp (compiler (+ 1 (<compiler>-level ocomp)))) (params (map-with gen-param (cadr defn) comp))) (print "static oop " (mangle-label name) "(") (let ((first 1)) (list-do param-name (cadr defn) (and (not first) (print ", ")) (set first ()) (print "oop " (mangle-label param-name)))) (println ")") (println "{") (set *c-indent* 1) (c-indent) (println "oop _eax = nil;") (let ((max-args (<compiler>-arg-limit comp))) (for (i 0 (>> max-args 2)) (c-indent) (println "oop _arg_" i " = nil;"))) (let ((max-temps (<compiler>-tmp-limit comp))) (for (i 0 (>> max-temps 2)) (c-indent) (println "oop " (c-temp-name (TI32 (* i 4))) " = nil;"))) (list-do e body (gen e comp)) (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i))) (and (<compiler>-epilogue comp) (let () (println (<compiler>-epilogue comp) ":") (c-indent))) (println "return _eax;") (set *c-indent* 0) (println "}") (println) (set *c-functions* (cons name *c-functions*)) (or main (let () (println "static oop v_" name " = (oop)" name ";") (set *c-globals* (cons name *c-globals*))))) (let* ((main (= (quote main) name)) (defn (<expr>-defn self)) (body (cddr defn)) (comp (compiler (+ 1 (<compiler>-level ocomp)))) (tnam (if main (LABEL name) (LABEL (temp-label-name)))) (vnam (if main () (LABEL name))) (params (map-with gen-param (cadr defn) comp))) (list-do e body (gen e comp)) (let* ((arg-size (align 16 (<compiler>-arg-limit comp))) (tmp-size (align 16 (+ arg-size (<compiler>-tmp-limit comp)))) (frm-size (align 16 (+ tmp-size 8)))) (map (lambda (tmp) (set (<TI32>-offset tmp) (+ arg-size (<TI32>-offset tmp)))) (<compiler>-temps comp)) (map (lambda (tmp) (set (<TI32>-offset tmp) (+ frm-size (<TI32>-offset tmp)))) params) (emit TEXT) (and main (emit GLOBAL tnam)) (emit DEFLABEL tnam) (emit COMMENT (list "frame " arg-size " " (<compiler>-tmp-limit comp) " " tmp-size " " frm-size)) (emit ENTER (- frm-size 8)) (for (i 0 (<compiler>-pc comp)) (apply emit (array-at (<compiler>-asm comp) i))) (and (<compiler>-epilogue comp) (emit DEFLABEL (<compiler>-epilogue comp))) (emit LEAVE (- frm-size 8))) (or main (let () (gen ocomp DATA) (gen ocomp GLOBAL vnam) (gen ocomp DEFLABEL vnam) (gen ocomp LONG tnam) (gen ocomp TEXT)))))))) (add-method gen-definition <long> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (println "static oop v_" name " = LONG(" self ");") (println)) (let () (gen comp DATA) (gen comp DEFLABEL (LABEL name)) (gen comp LONG self) (gen comp TEXT)))))) (add-method gen-definition <string> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (print "static wchar_t " name "_data[] = L") (dumpln self) (println ";") (println "static oop v_" name " = (oop)" name "_data;") (println)) (let ((temp (LABEL (temp-label-name)))) (gen comp DATA) (gen comp DEFLABEL temp) (gen comp ASCIZ self) (gen comp ALIGN 4) (gen comp DEFLABEL (LABEL name)) (gen comp LONG temp) (gen comp TEXT)))))) (add-method gen-definition <extern> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (let () (println "extern oop " (<extern>-name self) "();") (println "static oop v_" (concat-symbol (<extern>-name self) (quote $stub)) " = (oop)" (<extern>-name self) ";") (println)) (let ((nlabel (LABEL self.name)) (slabel (LABEL (concat-symbol self.name (quote $stub))))) (if (defined? (quote __MACH__)) (let () (gen comp SECTION "__IMPORT,__pointers,non_lazy_symbol_pointers") (gen comp DEFLABEL slabel) (gen comp INDIRECT nlabel) (gen comp LONG 0) (gen comp TEXT)) (gen comp DATA) (gen comp DEFLABEL slabel) (gen comp LONG nlabel) (gen comp TEXT))))))) (add-method gen-definition <form> (quote (self name comp)) (quote ((if (= *emit-backend* (quote c)) (println "/* form " name " */") (gen comp COMMENT (list "form " name)))))) (define gen-env-c (lambda (env) (println "// Generated by Maru emit-c backend") (println) (println "#include <stddef.h>") (println "#include <stdio.h>") (println "#include <stdlib.h>") (println "#include <string.h>") (println) (println "// Type definitions") (println "typedef union Object *oop;") (println) (println "// Runtime support") (println "#define nil ((oop)0)") (println "#define LONG(n) ((oop)(((long)(n) << 1) | 1))") (println "#define getLong(x) ((long)(x) >> 1)") (println) (println "// Global symbols") (println "static oop s_t = (oop)1;  // true value") (println) (println "// Forward declarations") (let ((vars (oop-at (%typecheck <env> env) 3))) (let ((index (array-length vars))) (while (<= 0 (set index (- index 1))) (let ((name (oop-at (%typecheck <variable> (array-at vars index)) 0)) (value (oop-at (%typecheck <variable> (array-at vars index)) 1))) (and (= <expr> (type-of value)) (println "static oop " name "(oop);")))))) (println) (println "// Function definitions") (let ((vars (oop-at (%typecheck <env> env) 3))) (let ((comp (compiler 0))) (let ((index (array-length vars))) (while (<= 0 (set index (- index 1))) (let ((name (oop-at (%typecheck <variable> (array-at vars index)) 0)) (value (oop-at (%typecheck <variable> (array-at vars index)) 1))) (gen-definition value name comp)))))) (and (member? (quote main) *c-functions*) (let () (println "// Main entry point") (println "int main(int argc, char *argv[])") (println "{") (println "  oop result = main();") (println "  if (result != nil) {") (println "    printf(\"%ld\\n\", getLong(result));") (println "  }") (println "  return 0;") (println "}") (println)))))))
[?7h