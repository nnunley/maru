;;; emit-c-threaded-fixed.l -- Fixed Threaded Execution C Backend
;;;
;;; Generates C code using threaded execution model where each operation
;;; is a function that calls the next operation directly (direct threading)

;;; Threaded C Generation State
(define *c-indent-level* 0)
(define *c-thread-counter* 0)
(define *c-var-names* ())

;;; Utility Functions
(define-function c-indent ()
  (for (i 0 *c-indent-level*) (print "    ")))

(define-function c-emit (str)
  (c-indent)
  (print str))

(define-function c-emit-line (str)
  (c-indent)
  (println str))

(define-function c-fresh-thread ()
  (let ((name (concat-string "thread_" (long->string (set *c-thread-counter* (+ *c-thread-counter* 1))))))
    name))

;;; Threaded Execution Framework
(define-function generate-threaded-c-header ()
  "Generate C header for threaded execution"
  (println "/* Generated by Maru Threaded C Backend */")
  (println "#include <stdio.h>")
  (println "#include <stdlib.h>")
  (println "#include <string.h>")
  (println)
  (println "typedef union Object *oop;")
  (println "#define nil ((oop)0)")
  (println "#define LONG(n) ((oop)(((long)(n) << 1) | 1))")
  (println "#define getLong(x) ((long)(x) >> 1)")
  (println)
  (println "/* Threaded execution context */")
  (println "typedef struct {")
  (println "    oop stack[1024];   /* Value stack */")
  (println "    oop *sp;           /* Stack pointer */")
  (println "    oop locals[256];   /* Local variables */")
  (println "    oop acc;           /* Accumulator */")
  (println "} thread_context;")
  (println)
  (println "typedef oop (*thread_func)(thread_context *ctx);")
  (println)
  (println "/* Stack operations */")
  (println "#define PUSH(ctx, val) (*((ctx)->sp++) = (val))")
  (println "#define POP(ctx) (*(--(ctx)->sp))")
  (println "#define PEEK(ctx) (*((ctx)->sp - 1))")
  (println))

;;; Threaded operation generators
(define-function c-gen-threaded-literal (value next)
  "Generate threaded code for literal value"
  (let ((thread-name (c-fresh-thread)))
    (print "oop ") (print thread-name) (println "(thread_context *ctx) {")
    (set *c-indent-level* 1)
    (c-emit "ctx->acc = ")
    (if (long? value)
        (print "LONG(" value ");")
        (print "nil;"))
    (println)
    (c-emit "return ") (print next) (println "(ctx);")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    thread-name))

(define-function c-gen-threaded-binop (op-str left-value right-value next)
  "Generate threaded code for binary operation"
  (let ((thread-name (c-fresh-thread)))
    (print "oop ") (print thread-name) (println "(thread_context *ctx) {")
    (set *c-indent-level* 1)
    (c-emit "long left = ") (print left-value) (println ";")
    (c-emit "long right = ") (print right-value) (println ";")
    (c-emit "ctx->acc = LONG(left ") (print op-str) (print " right);") (println)
    (c-emit "return ") (print next) (println "(ctx);")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    thread-name))

(define-function c-gen-threaded-return ()
  "Generate threaded code for return"
  (let ((thread-name (c-fresh-thread)))
    (print "oop ") (print thread-name) (println "(thread_context *ctx) {")
    (set *c-indent-level* 1)
    (c-emit-line "return ctx->acc;")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    thread-name))

;;; Generate complete threaded function
(define-function generate-threaded-function ()
  "Generate a sample threaded function for: add(40, 2)"
  (generate-threaded-c-header)
  
  ;; Generate threads for: 40 + 2
  (let ((ret-thread (c-gen-threaded-return))
        (thread-add (c-gen-threaded-binop "+" 40 2 "thread_1")))
    
    ;; Main function
    (println "oop add_42_threaded() {")
    (set *c-indent-level* 1)
    (c-emit-line "thread_context ctx = {0};")
    (c-emit-line "ctx.sp = ctx.stack;")
    (c-emit "return ") (print thread-add) (println "(&ctx);")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    
    ;; Test main
    (println "int main() {")
    (set *c-indent-level* 1)
    (c-emit-line "oop result = add_42_threaded();")
    (c-emit-line "printf(\"Threaded result: %ld\\n\", getLong(result));")
    (c-emit-line "return 0;")
    (set *c-indent-level* 0)
    (println "}")))

;;; Improved version that can handle expressions
(define-function c-gen-expr-to-threaded (expr next-thread)
  "Convert expression to threaded code"
  (cond
    ((long? expr)
     (c-gen-threaded-literal expr next-thread))
    
    ((pair? expr)
     (let ((op (car expr)))
       (cond
         ((= op '+)
          (let* ((left (cadr expr))
                 (right (caddr expr)))
            (if (and (long? left) (long? right))
                (c-gen-threaded-binop "+" left right next-thread)
                (error "Complex expressions not yet supported"))))
         
         (else
          (error "Unsupported operation: " op)))))
    
    (else
     (error "Unsupported expression type"))))

;;; Test expression compilation
(define-function test-expression-compilation ()
  "Test compiling simple expressions"
  (println "\n=== Expression Compilation Test ===")
  (generate-threaded-c-header)
  
  (let ((ret-thread (c-gen-threaded-return))
        (expr '(+ 10 32)))
    
    (println "/* Compiling expression: " expr " */")
    (let ((main-thread (c-gen-expr-to-threaded expr ret-thread)))
      
      (println "oop eval_expr() {")
      (set *c-indent-level* 1)
      (c-emit-line "thread_context ctx = {0};")
      (c-emit-line "ctx.sp = ctx.stack;")
      (c-emit "return ") (print main-thread) (println "(&ctx);")
      (set *c-indent-level* 0)
      (println "}")
      (println)
      
      (println "int main() {")
      (set *c-indent-level* 1)
      (c-emit-line "oop result = eval_expr();")
      (c-emit-line "printf(\"Expression result: %ld\\n\", getLong(result));")
      (c-emit-line "return 0;")
      (set *c-indent-level* 0)
      (println "}"))))

(println "emit-c-threaded-fixed.l loaded")