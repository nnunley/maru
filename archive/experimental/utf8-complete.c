/* Complete UTF-8 Support for Maru */
/* Generated by utf8-complete-system.l */

/* === Core UTF-8 Functions === */

/* UTF-8 character length from first byte */
static inline int utf8_char_length(unsigned char c) {
    if (c < 0x80) return 1;
    if (c < 0xE0) return 2;
    if (c < 0xF0) return 3;
    if (c < 0xF8) return 4;
    return 0; /* Invalid */
}

/* Decode UTF-8 sequence to codepoint */
static uint32_t utf8_decode_char(const unsigned char* s, int* len) {
    int n = utf8_char_length(s[0]);
    uint32_t cp = 0;
    *len = n;
    switch(n) {
        case 1: cp = s[0]; break;
        case 2: cp = ((s[0] & 0x1F) << 6) | (s[1] & 0x3F); break;
        case 3: cp = ((s[0] & 0x0F) << 12) | ((s[1] & 0x3F) << 6) | (s[2] & 0x3F); break;
        case 4: cp = ((s[0] & 0x07) << 18) | ((s[1] & 0x3F) << 12) | ((s[2] & 0x3F) << 6) | (s[3] & 0x3F); break;
        default: *len = 1; cp = 0xFFFD; /* Replacement character */
    }
    return cp;
}

/* === Unicode Properties === */

typedef enum {
    SCRIPT_COMMON, SCRIPT_LATIN, SCRIPT_GREEK, SCRIPT_CYRILLIC,
    SCRIPT_HEBREW, SCRIPT_ARABIC, SCRIPT_DEVANAGARI,
    SCRIPT_HIRAGANA, SCRIPT_KATAKANA, SCRIPT_HAN,
    SCRIPT_HANGUL, SCRIPT_EMOJI
} unicode_script;

/* Get script for codepoint */
static unicode_script get_script(uint32_t cp) {
    if (cp < 0x80) return SCRIPT_LATIN;
    if (cp >= 0x0370 && cp < 0x0400) return SCRIPT_GREEK;
    if (cp >= 0x0400 && cp < 0x0530) return SCRIPT_CYRILLIC;
    if (cp >= 0x0590 && cp < 0x0600) return SCRIPT_HEBREW;
    if (cp >= 0x0600 && cp < 0x0700) return SCRIPT_ARABIC;
    if (cp >= 0x3040 && cp < 0x30A0) return SCRIPT_HIRAGANA;
    if (cp >= 0x30A0 && cp < 0x3100) return SCRIPT_KATAKANA;
    if (cp >= 0x4E00 && cp < 0xA000) return SCRIPT_HAN;
    if (cp >= 0xAC00 && cp < 0xD7B0) return SCRIPT_HANGUL;
    if (cp >= 0x1F600 && cp < 0x1F650) return SCRIPT_EMOJI;
    return SCRIPT_COMMON;
}

/* === Bidirectional Text Support === */

typedef enum { DIR_LTR, DIR_RTL, DIR_NEUTRAL } text_direction;

static text_direction char_direction(uint32_t cp) {
    unicode_script script = get_script(cp);
    if (script == SCRIPT_HEBREW || script == SCRIPT_ARABIC)
        return DIR_RTL;
    if (script == SCRIPT_LATIN || script == SCRIPT_HAN)
        return DIR_LTR;
    return DIR_NEUTRAL;
}

/* === Normalization === */

/* Check if character needs normalization */
static int needs_normalization(uint32_t cp) {
    return (cp >= 0x00C0 && cp <= 0x00FF) ||  /* Latin-1 accented */
           (cp >= 0x0300 && cp <= 0x036F) ||  /* Combining marks */
           (cp >= 0xAC00 && cp <= 0xD7AF) ||  /* Hangul syllables */
           (cp >= 0xFB00 && cp <= 0xFB06);    /* Ligatures */
}

/* === Collation Support === */

typedef struct {
    uint16_t primary;
    uint8_t secondary;
    uint8_t tertiary;
} collation_weight;

/* Get collation weight for character */
static collation_weight get_weight(uint32_t cp, const char* locale) {
    collation_weight w = {0, 0, 0};
    
    /* ASCII fast path */
    if (cp < 0x80) {
        if (cp >= 'A' && cp <= 'Z') {
            w.primary = cp - 'A' + 100;
            w.tertiary = 1; /* Uppercase */
        } else if (cp >= 'a' && cp <= 'z') {
            w.primary = cp - 'a' + 100;
            w.tertiary = 2; /* Lowercase */
        } else if (cp >= '0' && cp <= '9') {
            w.primary = cp - '0' + 50;
        } else {
            w.primary = cp;
        }
        return w;
    }
    
    /* Script-based primary weights */
    unicode_script script = get_script(cp);
    switch(script) {
        case SCRIPT_LATIN:    w.primary = 1000 + cp; break;
        case SCRIPT_GREEK:    w.primary = 2000 + cp; break;
        case SCRIPT_CYRILLIC: w.primary = 3000 + cp; break;
        case SCRIPT_HEBREW:   w.primary = 4000 + cp; break;
        case SCRIPT_ARABIC:   w.primary = 5000 + cp; break;
        case SCRIPT_HAN:      w.primary = 10000 + (cp - 0x4E00); break;
        case SCRIPT_HANGUL:   w.primary = 20000 + (cp - 0xAC00); break;
        case SCRIPT_EMOJI:    w.primary = 30000 + cp; break;
        default:              w.primary = cp;
    }
    
    return w;
}

/* === UTF-8 String Comparison === */

static int utf8_compare_locale(const char* s1, const char* s2, const char* locale) {
    const unsigned char* p1 = (const unsigned char*)s1;
    const unsigned char* p2 = (const unsigned char*)s2;
    
    while (*p1 && *p2) {
        int len1, len2;
        uint32_t cp1 = utf8_decode_char(p1, &len1);
        uint32_t cp2 = utf8_decode_char(p2, &len2);
        
        collation_weight w1 = get_weight(cp1, locale);
        collation_weight w2 = get_weight(cp2, locale);
        
        if (w1.primary != w2.primary)
            return w1.primary - w2.primary;
        if (w1.secondary != w2.secondary)
            return w1.secondary - w2.secondary;
        if (w1.tertiary != w2.tertiary)
            return w1.tertiary - w2.tertiary;
        
        p1 += len1;
        p2 += len2;
    }
    
    return *p1 - *p2;
}

/* === wchar_t Compatibility === */
#define wchar_t char
#define wcslen(s) utf8_strlen(s)
#define wcscmp(s1, s2) strcmp(s1, s2)
#define wcscpy(dst, src) strcpy(dst, src)
#define wcsdup(s) strdup(s)
typedef int wint_t;
#define getwc(fp) fgetc(fp)
#define ungetwc(c, fp) ungetc(c, fp)
#define putwc(c, fp) fputc(c, fp)
#define fwide(stream, mode) (mode)
#define wcstod(str, endptr) strtod(str, endptr)
#define wcstoul(str, endptr, base) strtoul(str, endptr, base)
#define swprintf snprintf

/* === Test Examples === */
/*
 * // ASCII test
 * assert(utf8_compare_locale("apple", "Apple", "en_US") > 0);
 * 
 * // French test
 * assert(utf8_compare_locale("élève", "eleve", "fr_FR") > 0);
 * 
 * // Chinese test
 * assert(utf8_compare_locale("北京", "上海", "zh_CN") != 0);
 * 
 * // Mixed scripts
 * assert(utf8_compare_locale("ABC", "你好", "en_US") < 0);
 * 
 * // RTL test
 * assert(char_direction(0x05D0) == DIR_RTL); // Hebrew Alef
 */
