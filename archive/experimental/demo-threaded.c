/* Generated by Maru Threaded C Backend */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef union Object *oop;
#define nil ((oop)0)
#define LONG(n) ((oop)(((long)(n) << 1) | 1))
#define getLong(x) ((long)(x) >> 1)

/* Threaded execution context */
typedef struct {
    oop stack[1024];   /* Value stack */
    oop *sp;           /* Stack pointer */
    oop locals[256];   /* Local variables */
    oop acc;           /* Accumulator */
} thread_context;

typedef oop (*thread_func)(thread_context *ctx);

/* Stack operations */
#define PUSH(ctx, val) (*((ctx)->sp++) = (val))
#define POP(ctx) (*(--(ctx)->sp))
#define PEEK(ctx) (*((ctx)->sp - 1))

/* Thread for literal 42 */
oop thread_1(thread_context *ctx) {
    ctx->acc = LONG(42);
    return ctx->acc;  /* Return (terminal thread) */
}

/* Thread for literal 40 */
oop thread_2(thread_context *ctx) {
    PUSH(ctx, LONG(40));
    return thread_1(ctx);  /* Chain to next thread */
}

/* Thread for addition */
oop thread_3(thread_context *ctx) {
    oop right = POP(ctx);
    oop left = POP(ctx);
    ctx->acc = LONG(getLong(left) + getLong(right));
    return ctx->acc;
}

/* Threaded add function */
oop add_threaded(oop a, oop b) {
    thread_context ctx = {0};
    ctx.sp = ctx.stack;
    PUSH(&ctx, a);
    PUSH(&ctx, b);
    thread_2(&ctx);  /* Start thread chain */
    return thread_3(&ctx);  /* Execute addition */
}

int main() {
    oop result = add_threaded(LONG(40), LONG(2));
    printf("Threaded result: %ld\n", getLong(result));
    return 0;
}