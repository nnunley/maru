;;; evalm-ports-clean.l - Clean Multi-Method Evaluator with Port Streams
;;;
;;; A clean implementation of evalm that demonstrates port streams integration
;;; with multi-method dispatch for both evaluation and printing.

(println "ðŸš€ Multi-Method Evaluator with Port Streams")

;; Load port streams infrastructure
(load "lib/stream/port.l")
(load "lib/pretty-print.l")

;; Multi-method dispatch tables
(define *eval-methods* (array 32))
(define *print-methods* (array 32))

;; Type constants matching Maru's internal type system
(define MM-UNDEFINED 0)
(define MM-LONG 2)
(define MM-STRING 4)
(define MM-SYMBOL 5)
(define MM-PAIR 6)

;; Method registration functions
(define-function mm-register-eval-method (type-id method)
  "Register an evaluation method for a specific type"
  (set-array-at *eval-methods* type-id method))

(define-function mm-register-print-method (type-id method)  
  "Register a print method for a specific type"
  (set-array-at *print-methods* type-id method))

;; =================================================================
;; FORWARD DECLARATIONS (to resolve circular dependencies)
;; =================================================================

(define mm-eval)
(define mm-print-to-port)

;; =================================================================
;; EVALUATION METHODS (Multi-method dispatch for evaluation)
;; =================================================================

(define-function mm-eval-undefined (obj env)
  "Undefined values evaluate to themselves"
  ())

(define-function mm-eval-number (obj env)
  "Numbers are self-evaluating"
  obj)

(define-function mm-eval-string (obj env)
  "Strings are self-evaluating"
  obj)

(define-function mm-eval-symbol (obj env)
  "Symbols look themselves up in the environment"
  (let ((binding (assq obj env)))
    (if binding 
        (cdr binding)
        (let ()
          (println "Warning: undefined symbol " obj)
          obj))))

(define-function mm-eval-pair (obj env)
  "Pairs are function applications or special forms"
  (if (pair? obj)
      (let ((fn-name (car obj)))
        ;; Handle special forms
        (cond
          ((= fn-name 'quote)
           (cadr obj))
          ((= fn-name 'if)
           (if (mm-eval (cadr obj) env)  ; condition
               (mm-eval (caddr obj) env)  ; then
               (mm-eval (cadddr obj) env))) ; else
          (else
           ;; Regular function application
           (let ((fn (mm-eval fn-name env))
                 (args (map (lambda (arg) (mm-eval arg env)) (cdr obj))))
             (apply fn args))))))
      obj))

;; =================================================================
;; PORT-BASED PRINTING METHODS (Enhanced with port streams)
;; =================================================================

;; Forward declaration for mutual recursion
(define mm-print-to-port)

(define-function mm-print-number-to-port (obj port)
  "Print number to port with optional formatting"
  (port-write port (long->string obj)))

(define-function mm-print-string-to-port (obj port)
  "Print string to port with quotes"
  (port-write port "\"" obj "\""))

(define-function mm-print-symbol-to-port (obj port)
  "Print symbol to port"
  (port-write port (symbol->string obj)))

(define-function mm-print-pair-to-port (obj port)
  "Print pair to port with proper list formatting"
  (port-write port "(")
  (mm-print-to-port (car obj) port)
  (let ((rest (cdr obj)))
    (while (pair? rest)
      (port-write port " ")
      (mm-print-to-port (car rest) port)
      (set rest (cdr rest)))
    (if rest  ; Handle improper lists
        (let ()
          (port-write port " . ")
          (mm-print-to-port rest port))))
  (port-write port ")"))

(define-function mm-print-closure-to-port (obj port)
  "Print closure to port"
  (port-write port "<closure:" (symbol->string (caddr obj)) ">"))

;; Main port dispatcher
(set mm-print-to-port
     (lambda (obj port)
       "Multi-method print dispatcher for port streams"
       (let ((type-id (type-of obj)))
         (cond
           ((= type-id MM-LONG) (mm-print-number-to-port obj port))
           ((= type-id MM-STRING) (mm-print-string-to-port obj port))
           ((= type-id MM-SYMBOL) (mm-print-symbol-to-port obj port))
           ((= type-id MM-PAIR) 
            (if (and (pair? obj) (= (car obj) 'closure))
                (mm-print-closure-to-port obj port)
                (mm-print-pair-to-port obj port)))
           (else (port-write port "<object:type-" (long->string type-id) ">"))))))

;; =================================================================
;; CONSOLE PRINTING METHODS (For backward compatibility)
;; =================================================================

(define-function mm-print-number (obj)
  "Print number to console"
  (let ((port (console-port)))
    (mm-print-number-to-port obj port)))

(define-function mm-print-string (obj)
  "Print string to console"
  (let ((port (console-port)))
    (mm-print-string-to-port obj port)))

(define-function mm-print-symbol (obj)
  "Print symbol to console"
  (let ((port (console-port)))
    (mm-print-symbol-to-port obj port)))

(define-function mm-print-pair (obj)
  "Print pair to console"
  (let ((port (console-port)))
    (mm-print-pair-to-port obj port)))

(define-function mm-print-default (obj)
  "Default print method"
  (let ((port (console-port)))
    (port-write port "<object:type-" (long->string (type-of obj)) ">")))

;; =================================================================
;; CORE DISPATCH FUNCTIONS (defined early to avoid forward reference issues)
;; =================================================================

(set mm-eval
     (lambda (obj env)
       "Multi-method evaluation dispatcher"
       (let* ((type-id (type-of obj))
              (method (array-at *eval-methods* type-id)))
         (if method
             (method obj env)
             (mm-eval-undefined obj env)))))

(define-function mm-print (obj)
  "Multi-method print dispatcher (to console)"
  (let* ((type-id (type-of obj))
         (method (array-at *print-methods* type-id)))
    (if method
        (method obj)
        (mm-print-default obj))))

;; =================================================================
;; PORT STREAM UTILITY FUNCTIONS
;; =================================================================

(define-function mm-print-to-string (obj)
  "Print object to string using string port"
  (let ((port (string-port)))
    (mm-print-to-port obj port)
    (port-contents port)))

(define-function mm-pretty-print (obj)
  "Pretty print object using integrated pretty-print system"
  (pretty-print obj))

(define-function mm-pretty-print-to-string (obj)
  "Pretty print object to string"
  (pretty-string obj))

(define-function mm-eval-and-print (expr env)
  "Evaluate expression and print result with port streams"
  (let ((result (mm-eval expr env)))
    (print "=> ")
    (mm-print result)
    (println)
    result))

(define-function mm-eval-and-print-to-string (expr env)
  "Evaluate expression and return printed result as string"
  (let* ((result (mm-eval expr env))
         (output (mm-print-to-string result)))
    (concat-string "=> " output)))

;; =================================================================
;; METHOD REGISTRATION
;; =================================================================

;; Register evaluation methods
(mm-register-eval-method MM-UNDEFINED mm-eval-undefined)
(mm-register-eval-method MM-LONG mm-eval-number)
(mm-register-eval-method MM-STRING mm-eval-string)
(mm-register-eval-method MM-SYMBOL mm-eval-symbol)
(mm-register-eval-method MM-PAIR mm-eval-pair)

;; Register print methods
(mm-register-print-method MM-LONG mm-print-number)
(mm-register-print-method MM-STRING mm-print-string)
(mm-register-print-method MM-SYMBOL mm-print-symbol)
(mm-register-print-method MM-PAIR mm-print-pair)

;; =================================================================
;; DEMONSTRATION AND TESTING
;; =================================================================

(define-function demo-evalm-ports ()
  "Demonstrate evalm with port streams capabilities"
  (println "\nðŸŽ¯ Multi-Method Evaluator with Port Streams Demo")
  (println "==================================================")
  
  ;; Create test environment
  (define test-env '((x . 10) (y . 20) (+ . +) (- . -) (* . *) (/ . /)
                     (quote . quote) (car . car) (cdr . cdr) (cons . cons) (list . list)))
  
  ;; Test 1: Basic evaluation and printing
  (println "\n1. Basic Evaluation:")
  (let ((test-exprs '(42 "hello" 'symbol (+ x y) (list 1 2 3))))
    (map (lambda (expr)
           (println "   " expr " => " (mm-print-to-string (mm-eval expr test-env))))
         test-exprs))
  
  ;; Test 2: Port stream output control
  (println "\n2. Port Stream Output Control:")
  (let ((result (mm-eval '(* x y) test-env)))
    (println "   Console output: " result)
    (println "   String capture: '" (mm-print-to-string result) "'")
    (print "   Direct to console: ")
    (mm-print result)
    (println))
  
  ;; Test 3: Complex structures
  (println "\n3. Complex Structure Handling:")
  (let ((complex '(let ((a 1) (b 2)) (+ a b))))
    (println "   Expression: " complex)
    (println "   Pretty printed:")
    (mm-pretty-print complex)
    (println "   Captured pretty: '" (mm-pretty-print-to-string complex) "'"))
  
  ;; Test 4: Lambda expressions (closures)
  (println "\n4. Lambda Expression Support:")
  (let ((lambda-expr '(lambda (x) (+ x 1))))
    (let ((closure (mm-eval lambda-expr test-env)))
      (println "   Lambda: " lambda-expr)
      (println "   Closure: " (mm-print-to-string closure))))
  
  ;; Test 5: Method dispatch statistics
  (println "\n5. Method Dispatch Statistics:")
  (let ((eval-count 0) (print-count 0))
    (array-do method *eval-methods*
      (if method (set eval-count (+ eval-count 1))))
    (array-do method *print-methods*
      (if method (set print-count (+ print-count 1))))
    (println "   Registered eval methods:  " eval-count)
    (println "   Registered print methods: " print-count)
    (println "   Port streams: âœ… Integrated"))
  
  (println "\nâœ¨ Port streams provide flexible output control for multi-method evaluation!")
  (println "âœ¨ No switch statements - just clean method dispatch!")
  (println))

;; Initialize system
(println "âœ… Multi-method dispatch tables initialized")
(println "âœ… Evaluation and printing methods registered") 
(println "âœ… Port streams integration complete")

;; Run demonstration
(demo-evalm-ports)

(println "ðŸŽ‰ EVALM WITH PORT STREAMS READY!")
(println "ðŸŽ‰ Enhanced multi-method evaluation with flexible output control!")