;;; emit-c-threaded-working.l -- Working Threaded C Backend with Forward Declarations
;;;
;;; Simplified version that actually works

(load "emit-c-threaded-fixed.l")

;;; Define reverse if not available
(if (not (defined? 'reverse))
    (define-function reverse (lst)
      (let ((result ()))
        (while lst
          (set result (cons (car lst) result))
          (set lst (cdr lst)))
        result)))

;;; Global state for managing forward declarations
(define *all-threads* ())           ; List of all thread names
(define *thread-definitions* ())    ; List of thread definitions as strings

;;; Modified thread generation that collects definitions

(define-function c-gen-threaded-literal-fwd (value next)
  "Generate literal thread with forward declaration support"
  (let ((thread-name (c-fresh-thread)))
    ;; Record thread name
    (set *all-threads* (cons thread-name *all-threads*))
    
    ;; Generate definition
    (let ((def (list
                 "oop " thread-name "(thread_context *ctx) {\n"
                 "    ctx->acc = "
                 (if (long? value)
                     (list "LONG(" value ")")
                     "nil")
                 ";\n"
                 "    return " next "(ctx);\n"
                 "}\n\n")))
      (set *thread-definitions* (cons def *thread-definitions*)))
    
    thread-name))

(define-function c-gen-threaded-binop-fwd (op-str left right next)
  "Generate binary operation thread with forward declaration support"
  (let ((thread-name (c-fresh-thread)))
    ;; Record thread name
    (set *all-threads* (cons thread-name *all-threads*))
    
    ;; Generate definition
    (let ((def (list
                 "oop " thread-name "(thread_context *ctx) {\n"
                 "    ctx->acc = LONG(" left " " op-str " " right ");\n"
                 "    return " next "(ctx);\n"
                 "}\n\n")))
      (set *thread-definitions* (cons def *thread-definitions*)))
    
    thread-name))

(define-function c-gen-threaded-return-fwd ()
  "Generate return thread with forward declaration support"
  (let ((thread-name (c-fresh-thread)))
    ;; Record thread name
    (set *all-threads* (cons thread-name *all-threads*))
    
    ;; Generate definition
    (let ((def (list
                 "oop " thread-name "(thread_context *ctx) {\n"
                 "    return ctx->acc;\n"
                 "}\n\n")))
      (set *thread-definitions* (cons def *thread-definitions*)))
    
    thread-name))

;;; Helper to print nested lists
(define-function print-list (lst)
  "Print a nested list structure"
  (cond
    ((not lst) ())  ; Use not instead of null?
    ((pair? lst)
     (print-list (car lst))
     (print-list (cdr lst)))
    ((string? lst) (print lst))
    ((long? lst) (print lst))
    (else (print lst))))

;;; Main compilation function with forward declarations

(define-function compile-with-forwards (expr)
  "Compile expression with forward declarations"
  
  ;; Reset state
  (set *all-threads* ())
  (set *thread-definitions* ())
  (set *c-thread-counter* 0)
  
  ;; Generate header
  (println "/* Generated by Threaded C Compiler with Forward Declarations */")
  (println "#include <stdio.h>")
  (println "#include <stdlib.h>")
  (println)
  
  ;; Type definitions
  (println "typedef union Object *oop;")
  (println "#define nil ((oop)0)")
  (println "#define LONG(n) ((oop)(((long)(n) << 1) | 1))")
  (println "#define getLong(x) ((long)(x) >> 1)")
  (println)
  
  (println "typedef struct {")
  (println "    oop stack[1024];")
  (println "    oop *sp;")
  (println "    oop acc;")
  (println "} thread_context;")
  (println)
  
  ;; Compile the expression
  (let* ((ret-thread (c-gen-threaded-return-fwd))
         (main-thread (cond
                        ((and (pair? expr) (= (car expr) '+))
                         (c-gen-threaded-binop-fwd "+" (cadr expr) (caddr expr) ret-thread))
                        ((long? expr)
                         (c-gen-threaded-literal-fwd expr ret-thread))
                        (else
                         (error "Unsupported expression")))))
    
    ;; Generate forward declarations
    (println "/* Forward declarations */")
    (if *all-threads*
        (let ((threads (reverse *all-threads*)))
          (while threads
            (print "oop ") (print (car threads)) (println "(thread_context *ctx);")
            (set threads (cdr threads))))
        (println "/* No threads generated */"))
    (println)
    
    ;; Generate thread definitions
    (println "/* Thread definitions */")
    (let ((defs (reverse *thread-definitions*)))
      (while defs
        (print-list (car defs))
        (set defs (cdr defs))))
    
    ;; Generate main
    (println "int main() {")
    (println "    thread_context ctx = {0};")
    (println "    ctx.sp = ctx.stack;")
    (print "    oop result = ") (print main-thread) (println "(&ctx);")
    (println "    printf(\"Result: %ld\\n\", getLong(result));")
    (println "    return 0;")
    (println "}")))

;;; Test functions

(define-function test-working-compiler ()
  "Test the working compiler"
  (println "=== Testing Working Threaded C Compiler ===")
  (println)
  
  ;; Test 1: Simple literal
  (println "Test 1: Compiling 42")
  (compile-with-forwards 42)
  (println)
  
  ;; Test 2: Simple addition
  (println "Test 2: Compiling (+ 40 2)")
  (set *all-threads* ())
  (set *thread-definitions* ())
  (set *c-thread-counter* 0)
  (compile-with-forwards '(+ 40 2)))

(println "emit-c-threaded-working.l loaded")