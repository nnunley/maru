- change semaphores to signals
  
  nile_main()

  for (;;) {
    nile_lock ()
      k = nl->ready_q;
      if (k) 
        nl->ready_q = k->next;
      else
        nl->nthreads_active--;
      shutdown = nl->shutdown;
    nile_unlock ()

    if (shutdown)
      break;

    if (k) {
      ...exec k
    }
    else {
      nile_Signal_wait (nl->ready_q_signal);
      nile_lock ()
        nl->threads_active++;
      nile_unlock ()
    }
  }

- rethink naming:
    - nile_main processes kernels
    - nile_Kernel_exec processes stream buffers
    - k->process (of type nile_Kernel_process_t) processes stream elements

- port to Linux and Windows
- store an nl var in the kernel (and buffer?) struct
- Make sure that we can handle buffers with n = 0
    - initialize blocks or peek statements have to check that the
      input stream isn't empty, I think.
    - Does that mean that we have to send an empty buffer for eos?
    - Does that mean that initialize blocks (that reference the first element)
      have to check that the in buffers n != 0?
- make ready_q stuff to avoid using the sys-level semaphore.
- make nile_Kernel_exec aware of the shutdown flag?
- rename certain parts to match OS terminology (e.g., OS process state names)?
- rename nile_feed to nile_send ?
- nile.c should be using nile_Real_... operations in some places
- align the incoming memory to 32-bits (to ensure atomic ops)?
  or refuse memory that isn't aligned?
- use binary semaphores (Events on Win32?) instead of
  counting semaphores, since we can count ourselves and just
  need a sleep/wakup mechanism
- on uniprocessors, we should make nile_pause relinquish the processor?
  what other things should we be avoiding/skipping on uniprocessors?
  make things work even for nthreads = 0?
- optimize SortBy for when the input stream is wholly contained
  in the first input buffer. Do an in-place sort and
  just forward the modified input buffer downstream
  Does this matter?
- rename "initialized" field to something related to first_time
  or prologue or something?
- what if they give us an input buffer that isn't a multiple of in_quantum?
  (obviously by mistake)
- handle the limit on number of kernels that can be pipelined.
  we just have to split them up into multiple pipelines, not too hard?
- should pipeline kernels even be n-ary?
