;;; emit-gc-c.l -- High-fidelity C code generation with full GC integration
;;;
;;; This backend generates C code that matches eval.c style exactly:
;;; - Full GC integration with GC_PROTECT/GC_UNPROTECT
;;; - Proper object allocation via newOops/newBits  
;;; - Type-safe accessors with get/set macros
;;; - Tagged integer support
;;; - Real struct definitions matching eval.c

;;; C code generation state
(define *c-indent* 0)
(define *c-temp-count* 0)
(define *c-protect-stack* ())

(define-function c-indent ()
  (for (i 0 *c-indent*) (print "  ")))

(define-function c-newline ()
  (println)
  (c-indent))

(define-function c-begin-block ()
  (println " {")
  (set *c-indent* (+ *c-indent* 1)))

(define-function c-end-block ()
  (set *c-indent* (- *c-indent* 1))
  (c-indent) (println "}"))

;;; GC Protection Management
(define-function c-protect-var (var)
  (c-indent) (println "GC_PROTECT(" var ");")
  (set *c-protect-stack* (cons var *c-protect-stack*)))

(define-function c-unprotect-var (var)
  (c-indent) (println "GC_UNPROTECT(" var ");")
  (set *c-protect-stack* (cdr *c-protect-stack*)))

(define-function c-unprotect-all ()
  (while *c-protect-stack*
    (c-unprotect-var (car *c-protect-stack*))))

;;; Generate proper C preamble with GC integration
(define-function c-generate-preamble ()
  (println "/* Generated by Maru emit-gc-c.l - High-fidelity C with GC */")
  (println)
  (println "#define _ISOC99_SOURCE 1")
  (println "#define _BSD_SOURCE 1")
  (println)
  (println "#include <stddef.h>")
  (println "#include <stdio.h>")  
  (println "#include <stdarg.h>")
  (println "#include <string.h>")
  (println "#include <signal.h>")
  (println "#include <sys/types.h>")
  (println "#include <errno.h>")
  (println "#include <wchar.h>")
  (println "#include <locale.h>")
  (println "#include <math.h>")
  (println "#if defined(__MACH__)")
  (println "# include <ffi/ffi.h>")
  (println "#else")
  (println "# include <ffi.h>")
  (println "#endif")
  (println "#include <assert.h>")
  (println)
  (println "extern int isatty(int);")
  (println)
  (println "#if defined(WIN32)")
  (println "# include <malloc.h>")
  (println "# define swnprintf(BUF, SIZE, FMT, ARG) swprintf(BUF, FMT, ARG)")
  (println "#else")
  (println "# define swnprintf swprintf")
  (println "#endif")
  (println)
  (println "#define TAG_INT 1")
  (println "#define GC_APP_HEADER int type;")
  (println "#define GC_SAVE 1")
  (println)
  (println "#include \"gc.c\"")
  (println "#include \"wcs.c\"")
  (println "#include \"buffer.c\"")
  (println)
  (println "union Object;")
  (println "typedef union Object *oop;")
  (println "typedef oop (*imp_t)(oop args, oop env);")
  (println)
  (println "#define nil ((oop)0)")
  (println)
  ;; Generate all the struct definitions
  (println "enum { Undefined, Data, Long, Double, String, Symbol, Pair, _Array, Array, Expr, Form, Fixed, Subr, Variable, Env, Context };")
  (println)
  (println "struct Data { };")
  (println "struct Long { long bits; };")
  (println "struct Double { double bits; };")
  (println "struct String { oop size; wchar_t *bits; };")
  (println "struct Symbol { wchar_t *bits; };")
  (println "struct Pair { oop head, tail, source; };")
  (println "struct Array { oop size, _array; };")
  (println "struct Expr { oop name, defn, ctx, profile; };")
  (println "struct Form { oop function, symbol; };")
  (println "struct Fixed { oop function; };")
  (println "struct Subr { wchar_t *name; imp_t imp; void *sig; int profile; };")
  (println "struct Variable { oop name, value, env, index, type; };")
  (println "struct Env { oop parent, level, offset, bindings, stable; };")
  (println "struct Context { oop home, env, bindings, callee, pc; };")
  (println)
  (println "union Object {")
  (println "  struct Data Data;")
  (println "  struct Long Long;") 
  (println "  struct Double Double;")
  (println "  struct String String;")
  (println "  struct Symbol Symbol;")
  (println "  struct Pair Pair;")
  (println "  struct Array Array;")
  (println "  struct Expr Expr;")
  (println "  struct Form Form;")
  (println "  struct Fixed Fixed;")
  (println "  struct Subr Subr;")
  (println "  struct Variable Variable;")
  (println "  struct Env Env;")
  (println "  struct Context Context;")
  (println "};")
  (println)
  ;; Generate accessor macros
  (println "#define setType(OBJ, TYPE) (ptr2hdr(OBJ)->type= (TYPE))")
  (println "#define getType(OBJ) ((OBJ) ? (((long)(OBJ) & 1) ? Long : ptr2hdr(OBJ)->type) : Undefined)")
  (println "#define is(TYPE, OBJ) ((OBJ) && (TYPE == getType(OBJ)))")
  (println "#define get(OBJ, TYPE, FIELD) ((OBJ)->TYPE.FIELD)")
  (println "#define set(OBJ, TYPE, FIELD, VALUE) ((OBJ)->TYPE.FIELD= (VALUE))")
  (println)
  (println "#define newBits(TYPE) _newBits(TYPE, sizeof(struct TYPE))")
  (println "#define newOops(TYPE) _newOops(TYPE, sizeof(struct TYPE))")
  (println)
  (println "static oop _newBits(int type, size_t size) { oop obj= GC_malloc_atomic(size); setType(obj, type); return obj; }")
  (println "static oop _newOops(int type, size_t size) { oop obj= GC_malloc(size); setType(obj, type); return obj; }")
  (println)
  ;; Tagged integer support
  (println "static inline int isLong(oop x) { return (((long)x & 1) || Long == getType(x)); }")
  (println "static inline oop newLong(long x) { if ((x ^ (x << 1)) < 0) { oop obj= newBits(Long); set(obj, Long,bits, x); return obj; } return ((oop)((x << 1) | 1)); }")
  (println "static inline long getLong(oop x) { if ((long)x & 1) return (long)x >> 1; return get(x, Long,bits); }")
  (println)
  ;; Forward declarations
  (println "/* Forward declarations for all global variables and functions */")
  (println))

;;; Helper to get temp name
(define-function c-temp-name (temp)
  (concat-string "_tmp" (long->string (>> (<TI32>-offset temp) 2))))

;;; Generate C variable declarations
(define-function c-declare-temps (comp)
  (let ((max-temps (<compiler>-tmp-limit comp)))
    (and (> max-temps 0)
         (let ((temp-count (>> max-temps 2)))
           (c-indent) (print "oop ")
           (for (i 0 temp-count)
             (and (> i 0) (print ", "))
             (print "_tmp" i))
           (println "= nil;")))))

(define-function c-declare-args (comp)
  (let ((max-args (<compiler>-arg-limit comp)))
    (and (> max-args 0)
         (let ((arg-count (>> max-args 2)))
           (c-indent) (print "oop ")
           (for (i 0 arg-count)
             (and (> i 0) (print ", "))
             (print "_arg" i))
           (println "= nil;")))))

;;; C OBJECT ALLOCATION WITH GC PROTECTION

(define-emit (ALLOC-PAIR)
  (c-indent) (println "oop _obj= newOops(Pair);")
  (c-protect-var "_obj")
  (c-indent) (println "_acc= _obj;"))

(define-emit (ALLOC-ARRAY long)
  (c-indent) (println "oop _obj= newOops(Array);")
  (c-protect-var "_obj")
  (c-indent) (println "oop _elts= _newOops(_Array, sizeof(oop) * " $1 ");")
  (c-protect-var "_elts")
  (c-indent) (println "set(_obj, Array,size, newLong(" $1 "));")
  (c-indent) (println "set(_obj, Array,_array, _elts);")
  (c-unprotect-var "_elts")
  (c-unprotect-var "_obj")
  (c-indent) (println "_acc= _obj;"))

(define-emit (ALLOC-STRING long)
  (c-indent) (println "wchar_t *_gstr= (wchar_t *)_newBits(-1, sizeof(wchar_t) * (" $1 " + 1));")
  (c-protect-var "_gstr")
  (c-indent) (println "oop _obj= newOops(String);")
  (c-protect-var "_obj")
  (c-indent) (println "set(_obj, String,size, newLong(" $1 "));")
  (c-indent) (println "set(_obj, String,bits, _gstr);")
  (c-unprotect-var "_obj")
  (c-unprotect-var "_gstr")
  (c-indent) (println "_acc= _obj;"))

;;; ARITHMETIC OPERATIONS (same as emit-c.l but with proper GC patterns)

(define-emit (NEG)              
  (c-indent) (println "_acc= newLong(-getLong(_acc));"))

(define-emit (ADD TI32)         
  (c-indent) (println "_acc= newLong(getLong(_acc) + getLong(" $1 "));"))

(define-emit (SUB TI32)         
  (c-indent) (println "_acc= newLong(getLong(_acc) - getLong(" $1 "));"))

(define-emit (MUL TI32)         
  (c-indent) (println "_acc= newLong(getLong(_acc) * getLong(" $1 "));"))

(define-emit (DIV TI32)         
  (c-indent) (println "_acc= newLong(getLong(_acc) / getLong(" $1 "));"))

;;; CONTROL FLOW

(define-emit (BR LABEL)         
  (c-indent) (println "goto " $1 ";"))

(define-emit (BF LABEL)         
  (c-indent) (println "if (!_acc) goto " $1 ";"))

(define-emit (BT LABEL)         
  (c-indent) (println "if (_acc) goto " $1 ";"))

(define-emit (LABEL LABEL)
  (println)
  (println $1 ":"))

;;; LOAD/STORE OPERATIONS

(define-emit (LOAD LI32)        
  (c-indent) (println "_acc= newLong(" $1 ");"))

(define-emit (LOAD LABEL)       
  (c-indent) (println "_acc= " $1 ";"))

(define-emit (LOAD GI32)        
  (c-indent) (println "_acc= " $1 ";"))

(define-emit (LOAD TI32)        
  (c-indent) (println "_acc= " $1 ";"))

(define-emit (STORE TI32)       
  (c-indent) (println $1 "= _acc;"))

(define-emit (STORE GI32)       
  (c-indent) (println $1 "= _acc;"))

;;; OBJECT ACCESS WITH PROPER TYPING

(define-emit (GET-HEAD)
  (c-indent) (println "_acc= get(_acc, Pair,head);"))

(define-emit (GET-TAIL) 
  (c-indent) (println "_acc= get(_acc, Pair,tail);"))

(define-emit (SET-HEAD TI32)
  (c-indent) (println "set(_acc, Pair,head, " $1 ");"))

(define-emit (SET-TAIL TI32)
  (c-indent) (println "set(_acc, Pair,tail, " $1 ");"))

;;; FUNCTION DEFINITIONS WITH GC INTEGRATION

(define-method gen-definition <expr> (name comp)
  (let* ((main (= 'main name))
         (defn (<expr>-defn self))
         (body (cddr defn))
         (params (map-with gen-param (cadr defn) comp)))
    
    ;; Generate function signature  
    (println "static oop " name "(")
    (let ((first 1))
      (list-do param params
        (and (not first) (print ", "))
        (set first ())
        (print "oop " (c-temp-name param))))
    (println ")")
    (c-begin-block)
    
    ;; Declare accumulator
    (c-indent) (println "oop _acc= nil;")
    
    ;; Declare temps and args
    (c-declare-temps comp)
    (c-declare-args comp)
    
    ;; Generate body with GC protection
    (list-do e body (gen e comp))
    
    ;; Generate assembly code
    (for (i 0 (<compiler>-pc comp))
      (apply emit (array-at (<compiler>-asm comp) i)))
    
    ;; Cleanup any remaining protections
    (c-unprotect-all)
    
    ;; Return
    (c-indent) (println "return _acc;")
    (c-end-block)
    (println)))

;;; Global variable definitions
(define-method gen-definition <long> (name comp)
  (println "static oop " name "= nil;  /* initialized to newLong(" self ") */"))

(define-method gen-definition <string> (name comp)
  (println "static oop " name "= nil;  /* initialized to newString(" self ") */"))

;;; Main environment generator
(define-function gen-env-gc-c (env)
  (c-generate-preamble)
  
  ;; Generate global variable declarations
  (let* ((vars (<env>-bindings env))
         (index (array-length vars)))
    (while (<= 0 (set index (- index 1)))
      (let ((name (<variable>-name (array-at vars index)))
            (value (<variable>-value (array-at vars index))))
        (gen-definition value name ()))))
  
  ;; Generate initialization function
  (println)
  (println "static void initialize_globals(void)")
  (c-begin-block)
  (let* ((vars (<env>-bindings env))
         (index (array-length vars)))
    (while (<= 0 (set index (- index 1)))
      (let ((name (<variable>-name (array-at vars index)))
            (value (<variable>-value (array-at vars index))))
        (cond
          ((= <long> (type-of value))
           (c-indent) (println name "= newLong(" value ");"))
          ((= <string> (type-of value))
           (c-indent) (print name "= newString(L") (dump value) (println ");"))
          ;; Add more types as needed
          ))))
  (c-end-block)
  (println))

;;; Override TI32 printing for C
(define-method do-print <TI32> () 
  (print (c-temp-name self)))