;;; emit-c-cps.l -- Continuation-Passing Style C Backend
;;;
;;; Generates C code using continuation-passing style where every
;;; function takes a continuation and calls it with the result

;;; CPS C Generation State
(define *c-indent-level* 0)
(define *c-cont-counter* 0)
(define *c-var-names* ())

;;; Utility Functions
(define-function c-indent ()
  (for (i 0 *c-indent-level*) (print "    ")))

(define-function c-emit-line (str)
  (c-indent)
  (println str))

(define-function c-fresh-cont ()
  (let ((name (concat-string "cont_" (long->string (set *c-cont-counter* (+ *c-cont-counter* 1))))))
    name))

(define-function c-var-name (var)
  (or (cdr (assq var *c-var-names*))
      (let ((name (concat-string "_v" (long->string (list-length *c-var-names*)))))
        (set *c-var-names* (cons (cons var name) *c-var-names*))
        name)))

;;; CPS Framework
(define-function generate-cps-c-header ()
  "Generate C header for continuation-passing style"
  (println "/* Generated by Maru Continuation-Passing Style C Backend */")
  (println "#include <stdio.h>")
  (println "#include <stdlib.h>")
  (println "#include <string.h>")
  (println)
  (println "typedef union Object *oop;")
  (println "#define nil ((oop)0)")
  (println "#define LONG(n) ((oop)(((long)(n) << 1) | 1))")
  (println "#define getLong(x) ((long)(x) >> 1)")
  (println)
  (println "/* Continuation type */")
  (println "typedef struct continuation continuation;")
  (println "typedef oop (*cont_func)(oop value, continuation *cont);")
  (println)
  (println "struct continuation {")
  (c-indent) (println "    cont_func func;")
  (c-indent) (println "    oop env[16];       /* Closure environment */")
  (c-indent) (println "    continuation *next; /* Next continuation */")
  (println "};")
  (println)
  (println "/* Continuation constructors */")
  (println "continuation *make_cont(cont_func func, continuation *next) {")
  (c-indent) (println "    continuation *cont = malloc(sizeof(continuation));")
  (c-indent) (println "    cont->func = func;")
  (c-indent) (println "    cont->next = next;")
  (c-indent) (println "    return cont;")
  (println "}")
  (println)
  (println "/* Apply continuation */")
  (println "oop apply_cont(oop value, continuation *cont) {")
  (c-indent) (println "    return cont->func(value, cont);")
  (println "}")
  (println))

;;; CPS operation generators
(define-function c-gen-cps-literal (value cont-name)
  "Generate CPS code for literal value"
  (let ((func-name (c-fresh-cont)))
    (println "oop " func-name "(oop unused, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line (concat-string "oop value = " (if (long? value)
                                                    (concat-string "LONG(" (long->string value) ")")
                                                    "nil") ";"))
    (c-emit-line (concat-string "return apply_cont(value, " cont-name ");"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    func-name))

(define-function c-gen-cps-binop (op-str left-expr right-expr cont-name)
  "Generate CPS code for binary operation"
  (let ((func-name (c-fresh-cont))
        (left-cont (c-fresh-cont))
        (right-cont (c-fresh-cont)))
    
    ;; Right operand continuation
    (println "oop " right-cont "(oop right, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "oop left = cont->env[0];")
    (c-emit-line (concat-string "oop result = LONG(getLong(left) " op-str " getLong(right));"))
    (c-emit-line (concat-string "return apply_cont(result, " cont-name ");"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    
    ;; Left operand continuation
    (println "oop " left-cont "(oop left, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "continuation *right_cont = make_cont(" right-cont ", cont->next);")
    (c-emit-line "right_cont->env[0] = left;")
    (c-emit-line (concat-string "return " right-expr "(nil, right_cont);"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    
    ;; Main function
    (println "oop " func-name "(oop unused, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "continuation *left_cont = make_cont(" left-cont ", cont);")
    (c-emit-line (concat-string "return " left-expr "(nil, left_cont);"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    func-name))

(define-function c-gen-cps-call (func-name args cont-name)
  "Generate CPS code for function call"
  (let ((call-func (c-fresh-cont)))
    (println "oop " call-func "(oop unused, continuation *cont) {")
    (set *c-indent-level* 1)
    ;; For simplicity, assume binary function
    (c-emit-line "oop arg1 = cont->env[0];")
    (c-emit-line "oop arg2 = cont->env[1];")
    (c-emit-line (concat-string "oop result = " func-name "_cps(arg1, arg2);"))
    (c-emit-line (concat-string "return apply_cont(result, " cont-name ");"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    call-func))

(define-function c-gen-cps-if (cond-expr then-expr else-expr cont-name)
  "Generate CPS code for conditional"
  (let ((if-func (c-fresh-cont))
        (cond-cont (c-fresh-cont)))
    
    ;; Condition continuation
    (println "oop " cond-cont "(oop condition, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "if (condition != nil) {")
    (set *c-indent-level* 2)
    (c-emit-line (concat-string "return " then-expr "(nil, cont);"))
    (set *c-indent-level* 1)
    (c-emit-line "} else {")
    (set *c-indent-level* 2)
    (c-emit-line (concat-string "return " else-expr "(nil, cont);"))
    (set *c-indent-level* 1)
    (c-emit-line "}")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    
    ;; Main if function
    (println "oop " if-func "(oop unused, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "continuation *cond_cont = make_cont(" cond-cont ", cont);")
    (c-emit-line (concat-string "return " cond-expr "(nil, cond_cont);"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    if-func))

(define-function c-gen-cps-identity ()
  "Generate identity continuation (for return)"
  (let ((id-cont (c-fresh-cont)))
    (println "oop " id-cont "(oop value, continuation *cont) {")
    (set *c-indent-level* 1)
    (c-emit-line "return value;")
    (set *c-indent-level* 0)
    (println "}")
    (println)
    id-cont))

;;; Generate complete CPS function
(define-function generate-cps-function ()
  "Generate a sample CPS function"
  (generate-cps-c-header)
  
  (let ((id-cont (c-gen-cps-identity))
        (lit40-func (c-fresh-cont))
        (lit2-func (c-fresh-cont))
        (add-func ()))
    
    ;; Literal 40
    (set lit40-func (c-gen-cps-literal 40 id-cont))
    
    ;; Literal 2
    (set lit2-func (c-gen-cps-literal 2 id-cont))
    
    ;; Addition 
    (set add-func (c-gen-cps-binop "+" lit40-func lit2-func id-cont))
    
    ;; CPS wrapper function
    (println "oop add_cps(oop a, oop b) {")
    (set *c-indent-level* 1)
    (c-emit-line "continuation *id = make_cont(" id-cont ", nil);")
    (c-emit-line "id->env[0] = a;")
    (c-emit-line "id->env[1] = b;")
    (c-emit-line (concat-string "return " add-func "(nil, id);"))
    (set *c-indent-level* 0)
    (println "}")
    (println)
    
    ;; Test main
    (println "int main() {")
    (set *c-indent-level* 1)
    (c-emit-line "oop result = add_cps(LONG(40), LONG(2));")
    (c-emit-line "printf(\"CPS result: %ld\\n\", getLong(result));")
    (c-emit-line "return 0;")
    (set *c-indent-level* 0)
    (println "}")))

;;; Callcc implementation
(define-function c-gen-callcc ()
  "Generate call/cc implementation"
  (println "/* call/cc implementation */")
  (println "oop callcc(cont_func proc, continuation *cont) {")
  (c-indent) (println "    /* Create escape continuation */")
  (c-indent) (println "    continuation *escape = make_cont(cont->func, cont->next);")
  (c-indent) (println "    /* Call proc with escape continuation */")
  (c-indent) (println "    return proc((oop)escape, cont);")
  (println "}")
  (println))

(println "emit-c-cps.l loaded")