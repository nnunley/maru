;; Complete UTF-8 System for Maru
;; Integrates UTF-8, normalization, collation, and full Unicode support

;; Skip these lines for C generation
;; (println "=== Complete UTF-8 System for Maru ===")
;; (println)

;; Load our components
;; (require "utf8-unicode-support.l")
;; (require "utf8-normalization.l")

;; Generate the complete UTF-8 C library
(define-function generate-complete-utf8-library ()
  (println "/* Complete UTF-8 Support for Maru */")
  (println "/* Generated by utf8-complete-system.l */")
  (println)
  
  ;; Core UTF-8 functions
  (println "/* === Core UTF-8 Functions === */")
  (println)
  (println "/* UTF-8 character length from first byte */")
  (println "static inline int utf8_char_length(unsigned char c) {")
  (println "    if (c < 0x80) return 1;")
  (println "    if (c < 0xE0) return 2;")
  (println "    if (c < 0xF0) return 3;")
  (println "    if (c < 0xF8) return 4;")
  (println "    return 0; /* Invalid */")
  (println "}")
  (println)
  
  (println "/* Decode UTF-8 sequence to codepoint */")
  (println "static uint32_t utf8_decode_char(const unsigned char* s, int* len) {")
  (println "    int n = utf8_char_length(s[0]);")
  (println "    uint32_t cp = 0;")
  (println "    *len = n;")
  (println "    switch(n) {")
  (println "        case 1: cp = s[0]; break;")
  (println "        case 2: cp = ((s[0] & 0x1F) << 6) | (s[1] & 0x3F); break;")
  (println "        case 3: cp = ((s[0] & 0x0F) << 12) | ((s[1] & 0x3F) << 6) | (s[2] & 0x3F); break;")
  (println "        case 4: cp = ((s[0] & 0x07) << 18) | ((s[1] & 0x3F) << 12) | ((s[2] & 0x3F) << 6) | (s[3] & 0x3F); break;")
  (println "        default: *len = 1; cp = 0xFFFD; /* Replacement character */")
  (println "    }")
  (println "    return cp;")
  (println "}")
  (println)
  
  (println "/* UTF-8 string length in characters (not bytes) */")
  (println "static size_t utf8_strlen(const char* str) {")
  (println "    size_t len = 0;")
  (println "    const unsigned char* s = (const unsigned char*)str;")
  (println "    while (*s) {")
  (println "        int char_len = utf8_char_length(*s);")
  (println "        if (char_len == 0) char_len = 1; /* Invalid byte, skip */")
  (println "        s += char_len;")
  (println "        len++;")
  (println "    }")
  (println "    return len;")
  (println "}")
  (println)
  
  ;; Unicode properties
  (println "/* === Unicode Properties === */")
  (println)
  (println "typedef enum {")
  (println "    SCRIPT_COMMON, SCRIPT_LATIN, SCRIPT_GREEK, SCRIPT_CYRILLIC,")
  (println "    SCRIPT_HEBREW, SCRIPT_ARABIC, SCRIPT_DEVANAGARI,")
  (println "    SCRIPT_HIRAGANA, SCRIPT_KATAKANA, SCRIPT_HAN,")
  (println "    SCRIPT_HANGUL, SCRIPT_EMOJI")
  (println "} unicode_script;")
  (println)
  
  (println "/* Get script for codepoint */")
  (println "static unicode_script get_script(uint32_t cp) {")
  (println "    if (cp < 0x80) return SCRIPT_LATIN;")
  (println "    if (cp >= 0x0370 && cp < 0x0400) return SCRIPT_GREEK;")
  (println "    if (cp >= 0x0400 && cp < 0x0530) return SCRIPT_CYRILLIC;")
  (println "    if (cp >= 0x0590 && cp < 0x0600) return SCRIPT_HEBREW;")
  (println "    if (cp >= 0x0600 && cp < 0x0700) return SCRIPT_ARABIC;")
  (println "    if (cp >= 0x3040 && cp < 0x30A0) return SCRIPT_HIRAGANA;")
  (println "    if (cp >= 0x30A0 && cp < 0x3100) return SCRIPT_KATAKANA;")
  (println "    if (cp >= 0x4E00 && cp < 0xA000) return SCRIPT_HAN;")
  (println "    if (cp >= 0xAC00 && cp < 0xD7B0) return SCRIPT_HANGUL;")
  (println "    if (cp >= 0x1F600 && cp < 0x1F650) return SCRIPT_EMOJI;")
  (println "    return SCRIPT_COMMON;")
  (println "}")
  (println)
  
  ;; Bidirectional support
  (println "/* === Bidirectional Text Support === */")
  (println)
  (println "typedef enum { DIR_LTR, DIR_RTL, DIR_NEUTRAL } text_direction;")
  (println)
  (println "static text_direction char_direction(uint32_t cp) {")
  (println "    unicode_script script = get_script(cp);")
  (println "    if (script == SCRIPT_HEBREW || script == SCRIPT_ARABIC)")
  (println "        return DIR_RTL;")
  (println "    if (script == SCRIPT_LATIN || script == SCRIPT_HAN)")
  (println "        return DIR_LTR;")
  (println "    return DIR_NEUTRAL;")
  (println "}")
  (println)
  
  ;; Normalization
  (println "/* === Normalization === */")
  (println)
  (println "/* Check if character needs normalization */")
  (println "static int needs_normalization(uint32_t cp) {")
  (println "    return (cp >= 0x00C0 && cp <= 0x00FF) ||  /* Latin-1 accented */")
  (println "           (cp >= 0x0300 && cp <= 0x036F) ||  /* Combining marks */")
  (println "           (cp >= 0xAC00 && cp <= 0xD7AF) ||  /* Hangul syllables */")
  (println "           (cp >= 0xFB00 && cp <= 0xFB06);    /* Ligatures */")
  (println "}")
  (println)
  
  ;; Collation
  (println "/* === Collation Support === */")
  (println)
  (println "typedef struct {")
  (println "    uint16_t primary;")
  (println "    uint8_t secondary;")
  (println "    uint8_t tertiary;")
  (println "} collation_weight;")
  (println)
  (println "/* Get collation weight for character */")
  (println "static collation_weight get_weight(uint32_t cp, const char* locale) {")
  (println "    collation_weight w = {0, 0, 0};")
  (println "    ")
  (println "    /* ASCII fast path */")
  (println "    if (cp < 0x80) {")
  (println "        if (cp >= 'A' && cp <= 'Z') {")
  (println "            w.primary = cp - 'A' + 100;")
  (println "            w.tertiary = 1; /* Uppercase */")
  (println "        } else if (cp >= 'a' && cp <= 'z') {")
  (println "            w.primary = cp - 'a' + 100;")
  (println "            w.tertiary = 2; /* Lowercase */")
  (println "        } else if (cp >= '0' && cp <= '9') {")
  (println "            w.primary = cp - '0' + 50;")
  (println "        } else {")
  (println "            w.primary = cp;")
  (println "        }")
  (println "        return w;")
  (println "    }")
  (println "    ")
  (println "    /* Script-based primary weights */")
  (println "    unicode_script script = get_script(cp);")
  (println "    switch(script) {")
  (println "        case SCRIPT_LATIN:    w.primary = 1000 + cp; break;")
  (println "        case SCRIPT_GREEK:    w.primary = 2000 + cp; break;")
  (println "        case SCRIPT_CYRILLIC: w.primary = 3000 + cp; break;")
  (println "        case SCRIPT_HEBREW:   w.primary = 4000 + cp; break;")
  (println "        case SCRIPT_ARABIC:   w.primary = 5000 + cp; break;")
  (println "        case SCRIPT_HAN:      w.primary = 10000 + (cp - 0x4E00); break;")
  (println "        case SCRIPT_HANGUL:   w.primary = 20000 + (cp - 0xAC00); break;")
  (println "        case SCRIPT_EMOJI:    w.primary = 30000 + cp; break;")
  (println "        default:              w.primary = cp;")
  (println "    }")
  (println "    ")
  (println "    return w;")
  (println "}")
  (println)
  
  ;; String comparison
  (println "/* === UTF-8 String Comparison === */")
  (println)
  (println "static int utf8_compare_locale(const char* s1, const char* s2, const char* locale) {")
  (println "    const unsigned char* p1 = (const unsigned char*)s1;")
  (println "    const unsigned char* p2 = (const unsigned char*)s2;")
  (println "    ")
  (println "    while (*p1 && *p2) {")
  (println "        int len1, len2;")
  (println "        uint32_t cp1 = utf8_decode_char(p1, &len1);")
  (println "        uint32_t cp2 = utf8_decode_char(p2, &len2);")
  (println "        ")
  (println "        collation_weight w1 = get_weight(cp1, locale);")
  (println "        collation_weight w2 = get_weight(cp2, locale);")
  (println "        ")
  (println "        if (w1.primary != w2.primary)")
  (println "            return w1.primary - w2.primary;")
  (println "        if (w1.secondary != w2.secondary)")
  (println "            return w1.secondary - w2.secondary;")
  (println "        if (w1.tertiary != w2.tertiary)")
  (println "            return w1.tertiary - w2.tertiary;")
  (println "        ")
  (println "        p1 += len1;")
  (println "        p2 += len2;")
  (println "    }")
  (println "    ")
  (println "    return *p1 - *p2;")
  (println "}")
  (println)
  
  ;; Compatibility layer
  (println "/* === wchar_t Compatibility === */")
  (println "#define wchar_t char")
  (println "#define wcslen(s) utf8_strlen(s)")
  (println "#define wcscmp(s1, s2) strcmp(s1, s2)")
  (println "#define wcscpy(dst, src) strcpy(dst, src)")
  (println "#define wcsdup(s) strdup(s)")
  (println "typedef int wint_t;")
  (println "#define getwc(fp) fgetc(fp)")
  (println "#define ungetwc(c, fp) ungetc(c, fp)")
  (println "#define putwc(c, fp) fputc(c, fp)")
  (println "#define fwide(stream, mode) (mode)")
  (println "#define wcstod(str, endptr) strtod(str, endptr)")
  (println "#define wcstoul(str, endptr, base) strtoul(str, endptr, base)")
  (println "#define swprintf snprintf")
  (println))

;; Generate the library
(generate-complete-utf8-library)

;; Test examples
(println "/* === Test Examples === */")
(println "/*")
(println " * // ASCII test")
(println " * assert(utf8_compare_locale(\"apple\", \"Apple\", \"en_US\") > 0);")
(println " * ")
(println " * // French test")  
(println " * assert(utf8_compare_locale(\"élève\", \"eleve\", \"fr_FR\") > 0);")
(println " * ")
(println " * // Chinese test")
(println " * assert(utf8_compare_locale(\"北京\", \"上海\", \"zh_CN\") != 0);")
(println " * ")
(println " * // Mixed scripts")
(println " * assert(utf8_compare_locale(\"ABC\", \"你好\", \"en_US\") < 0);")
(println " * ")
(println " * // RTL test")
(println " * assert(char_direction(0x05D0) == DIR_RTL); // Hebrew Alef")
(println " */")