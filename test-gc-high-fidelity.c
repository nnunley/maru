/* Generated by Maru emit-gc-c-simple.l - High-fidelity C with GC */

#define _ISOC99_SOURCE 1
#define _BSD_SOURCE 1

#include <stddef.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <errno.h>
#include <wchar.h>
#include <locale.h>
#include <math.h>
#if defined(__MACH__)
# include <ffi/ffi.h>
#else
# include <ffi.h>
#endif
#include <assert.h>

extern int isatty(int);

#if defined(WIN32)
# include <malloc.h>
# define swnprintf(BUF, SIZE, FMT, ARG) swprintf(BUF, FMT, ARG)
#else
# define swnprintf swprintf
#endif

#define TAG_INT 1
#define GC_APP_HEADER int type;
#define GC_SAVE 1

#include "gc.c"
#include "wcs.c"
#include "buffer.c"

union Object;
typedef union Object *oop;
typedef oop (*imp_t)(oop args, oop env);

#define nil ((oop)0)

enum { Undefined, Data, Long, Double, String, Symbol, Pair, _Array, Array, Expr, Form, Fixed, Subr, Variable, Env, Context };

struct Data { };
struct Long { long bits; };
struct Double { double bits; };
struct String { oop size; wchar_t *bits; };
struct Symbol { wchar_t *bits; };
struct Pair { oop head, tail, source; };
struct Array { oop size, _array; };
struct Expr { oop name, defn, ctx, profile; };
struct Form { oop function, symbol; };
struct Fixed { oop function; };
struct Subr { wchar_t *name; imp_t imp; void *sig; int profile; };
struct Variable { oop name, value, env, index, type; };
struct Env { oop parent, level, offset, bindings, stable; };
struct Context { oop home, env, bindings, callee, pc; };

union Object {
  struct Data Data;
  struct Long Long;
  struct Double Double;
  struct String String;
  struct Symbol Symbol;
  struct Pair Pair;
  struct Array Array;
  struct Expr Expr;
  struct Form Form;
  struct Fixed Fixed;
  struct Subr Subr;
  struct Variable Variable;
  struct Env Env;
  struct Context Context;
};

#define setType(OBJ, TYPE) (ptr2hdr(OBJ)->type= (TYPE))
#define getType(OBJ) ((OBJ) ? (((long)(OBJ) & 1) ? Long : ptr2hdr(OBJ)->type) : Undefined)
#define is(TYPE, OBJ) ((OBJ) && (TYPE == getType(OBJ)))
#define get(OBJ, TYPE, FIELD) ((OBJ)->TYPE.FIELD)
#define set(OBJ, TYPE, FIELD, VALUE) ((OBJ)->TYPE.FIELD= (VALUE))

#define newBits(TYPE) _newBits(TYPE, sizeof(struct TYPE))
#define newOops(TYPE) _newOops(TYPE, sizeof(struct TYPE))

static oop _newBits(int type, size_t size) { oop obj= GC_malloc_atomic(size); setType(obj, type); return obj; }
static oop _newOops(int type, size_t size) { oop obj= GC_malloc(size); setType(obj, type); return obj; }

static inline int isLong(oop x) { return (((long)x & 1) || Long == getType(x)); }
static inline oop newLong(long x) { if ((x ^ (x << 1)) < 0) { oop obj= newBits(Long); set(obj, Long,bits, x); return obj; } return ((oop)((x << 1) | 1)); }
static inline long getLong(oop x) { if ((long)x & 1) return (long)x >> 1; return get(x, Long,bits); }

static oop newString(wchar_t *str) {
  size_t len= wcslen(str);
  wchar_t *gstr= (wchar_t *)_newBits(-1, sizeof(wchar_t) * (len + 1)); GC_PROTECT(gstr);
  oop obj= newOops(String); GC_PROTECT(obj);
  wcscpy(gstr, str);
  set(obj, String,size, newLong(len));
  set(obj, String,bits, gstr); GC_UNPROTECT(obj); GC_UNPROTECT(gstr);
  return obj;
}

static oop newArray(long size) {
  long cap= size ? size : 1;
  oop elts= _newOops(_Array, sizeof(oop) * cap); GC_PROTECT(elts);
  oop obj= newOops(Array); GC_PROTECT(obj);
  set(obj, Array,size, newLong(size));
  set(obj, Array,_array, elts); GC_UNPROTECT(obj); GC_UNPROTECT(elts);
  return obj;
}

static oop newPair(oop head, oop tail) {
  oop obj= newOops(Pair); GC_PROTECT(obj);
  set(obj, Pair,head, head);
  set(obj, Pair,tail, tail);
  set(obj, Pair,source, nil); GC_UNPROTECT(obj);
  return obj;
}

/* Test functions demonstrating GC-integrated code generation */

static oop test_add(oop a, oop b) {
  /* Arithmetic with proper tagged integer handling */
  return newLong(getLong(a) + getLong(b));
}

static oop test_pair_creation(oop x, oop y) {
  /* Object creation with GC protection */
  return newPair(x, y);
}

static oop test_string_creation(oop len) {
  /* String allocation with GC protection */
  wchar_t *buf= (wchar_t *)_newBits(-1, sizeof(wchar_t) * (getLong(len) + 1)); GC_PROTECT(buf);
  oop obj= newOops(String); GC_PROTECT(obj);
  set(obj, String,size, len);
  set(obj, String,bits, buf); GC_UNPROTECT(obj); GC_UNPROTECT(buf);
  return obj;
}

int main(int argc, char **argv) {
  /* Initialize GC and UTF-8 locale */
  GC_init();
  setlocale(LC_ALL, "");  /* UTF-8 support */

  printf("=== High-Fidelity GC C Emitter Test ===\n");

  /* Test basic arithmetic with tagged integers */
  oop result1= test_add(newLong(5), newLong(3));
  printf("5 + 3 = %ld\n", getLong(result1));

  /* Test pair creation with GC protection */
  oop result2= test_pair_creation(newLong(42), newLong(17));
  printf("Pair: (%ld . %ld)\n", getLong(get(result2, Pair,head)), getLong(get(result2, Pair,tail)));

  /* Test string allocation with proper GC handling */
  oop result3= test_string_creation(newLong(10));
  printf("Created string of length: %ld\n", getLong(get(result3, String,size)));

  /* Test UTF-8 string creation */
  oop utf8_str= newString(L"UTF-8 Test: ‰Ω†Â•Ω‰∏ñÁïå üåç");
  printf("UTF-8 string length: %ld\n", getLong(get(utf8_str, String,size)));

  /* Force GC to test our generated objects survive collection */
  printf("Running GC...\n");
  GC_gcollect();
  printf("GC completed - all objects still accessible\n");

  /* Verify objects are still valid after GC */
  printf("Post-GC verification:\n");
  printf("  Arithmetic result: %ld\n", getLong(result1));
  printf("  Pair: (%ld . %ld)\n", getLong(get(result2, Pair,head)), getLong(get(result2, Pair,tail)));
  printf("  String length: %ld\n", getLong(get(result3, String,size)));
  printf("  UTF-8 string length: %ld\n", getLong(get(utf8_str, String,size)));

  printf("=== All tests passed! ===\n");
  return 0;
}
