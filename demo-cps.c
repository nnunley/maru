/* Generated by Maru Continuation-Passing Style C Backend */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef union Object *oop;
#define nil ((oop)0)
#define LONG(n) ((oop)(((long)(n) << 1) | 1))
#define getLong(x) ((long)(x) >> 1)

/* Continuation type */
typedef struct continuation continuation;
typedef oop (*cont_func)(oop value, continuation *cont);

struct continuation {
    cont_func func;
    oop env[16];       /* Closure environment */
    continuation *next; /* Next continuation */
};

/* Continuation constructors */
continuation *make_cont(cont_func func, continuation *next) {
    continuation *cont = malloc(sizeof(continuation));
    cont->func = func;
    cont->next = next;
    return cont;
}

/* Apply continuation */
oop apply_cont(oop value, continuation *cont) {
    if (cont == nil) return value;
    return cont->func(value, cont);
}

/* Identity continuation (terminal) */
oop cont_id(oop value, continuation *cont) {
    return value;
}

/* Addition continuation */
oop cont_add(oop right, continuation *cont) {
    oop left = cont->env[0];
    oop result = LONG(getLong(left) + getLong(right));
    return apply_cont(result, cont->next);
}

/* Continuation for left operand of addition */
oop cont_add_left(oop left, continuation *cont) {
    continuation *add_cont = make_cont(cont_add, cont->next);
    add_cont->env[0] = left;
    /* In a full implementation, this would evaluate the right operand */
    oop right = LONG(2);  /* Hardcoded for demo */
    return apply_cont(right, add_cont);
}

/* CPS add function */
oop add_cps(oop a, oop b) {
    continuation *id = make_cont(cont_id, nil);
    continuation *left_cont = make_cont(cont_add_left, id);
    return apply_cont(a, left_cont);
}

/* call/cc implementation */
oop callcc(cont_func proc, continuation *cont) {
    /* Create escape continuation */
    continuation *escape = make_cont(cont->func, cont->next);
    /* Call proc with escape continuation */
    return proc((oop)escape, cont);
}

/* Example: using call/cc to implement early return */
oop early_return_example(oop escape_cont, continuation *cont) {
    /* This would normally do some computation */
    printf("Before early return\n");
    
    /* Early return using the escape continuation */
    continuation *escape = (continuation*)escape_cont;
    return apply_cont(LONG(999), escape);
    
    /* This code is never reached */
    printf("After early return (never printed)\n");
    return LONG(42);
}

oop test_callcc() {
    continuation *id = make_cont(cont_id, nil);
    return callcc(early_return_example, id);
}

int main() {
    oop result = add_cps(LONG(40), LONG(2));
    printf("CPS result: %ld\n", getLong(result));
    
    oop callcc_result = test_callcc();
    printf("call/cc result: %ld\n", getLong(callcc_result));
    
    return 0;
}