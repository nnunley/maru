/* Source Location Tracking Demo - Generated by Maru */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <locale.h>

/* Simple GC simulation */
void *GC_malloc(size_t size) { return malloc(size); }
void *GC_malloc_atomic(size_t size) { return malloc(size); }
void GC_gcollect(void) { printf("[GC collection]\n"); }

/* GC Protection simulation */
struct GC_StackRoot { void *root; struct GC_StackRoot *next; };
static struct GC_StackRoot *gc_roots = NULL;
void GC_push_root_simple(struct GC_StackRoot *sr) { sr->next = gc_roots; gc_roots = sr; }
void GC_pop_root_simple(struct GC_StackRoot *sr) { if (gc_roots == sr) gc_roots = sr->next; }
#define GC_PROTECT(V) struct GC_StackRoot _sr_##V; _sr_##V.root = (void *)&V; GC_push_root_simple(&_sr_##V)
#define GC_UNPROTECT(V) GC_pop_root_simple(&_sr_##V)

/* Object system with source tracking */
typedef union Object *oop;
#define nil ((oop)0)

enum { Undefined, Long, String, Pair, SourceLocation };

struct Long { long bits; };
struct String { oop size; wchar_t *bits; };
struct Pair { oop head, tail, source; };
struct SourceLocation { oop filename, line, column; };

union Object {
  struct Long Long;
  struct String String;
  struct Pair Pair;
  struct SourceLocation SourceLocation;
};

/* Type system */
typedef struct { int type; } *header_t;
header_t obj2hdr(oop obj) { return (header_t)((char*)obj - sizeof(int)); }
void setType(oop obj, int type) { obj2hdr(obj)->type = type; }
int getType(oop obj) { return obj ? (((long)obj & 1) ? Long : obj2hdr(obj)->type) : Undefined; }
#define is(TYPE, OBJ) ((OBJ) && (TYPE == getType(OBJ)))
#define get(OBJ, TYPE, FIELD) ((OBJ)->TYPE.FIELD)
#define set(OBJ, TYPE, FIELD, VALUE) ((OBJ)->TYPE.FIELD= (VALUE))

/* Object allocation */
static oop _newBits(int type, size_t size) {
  char *mem = GC_malloc_atomic(size + sizeof(int));
  oop obj = (oop)(mem + sizeof(int));
  setType(obj, type); return obj;
}
static oop _newOops(int type, size_t size) {
  char *mem = GC_malloc(size + sizeof(int));
  oop obj = (oop)(mem + sizeof(int));
  setType(obj, type); return obj;
}
#define newBits(TYPE) _newBits(TYPE, sizeof(struct TYPE))
#define newOops(TYPE) _newOops(TYPE, sizeof(struct TYPE))

/* Tagged integers */
static inline oop newLong(long x) {
  if ((x ^ (x << 1)) < 0) {
    oop obj = newBits(Long);
    set(obj, Long, bits, x);
    return obj;
  }
  return ((oop)((x << 1) | 1));
}
static inline long getLong(oop x) {
  if ((long)x & 1) return (long)x >> 1;
  return get(x, Long, bits);
}

/* Source location tracking */
static oop current_filename = nil;
static long current_line = 1;
static long current_column = 1;

static oop newString(wchar_t *str) {
  size_t len = wcslen(str);
  wchar_t *gstr = (wchar_t *)_newBits(-1, sizeof(wchar_t) * (len + 1)); GC_PROTECT(gstr);
  oop obj = newOops(String); GC_PROTECT(obj);
  wcscpy(gstr, str);
  set(obj, String, size, newLong(len));
  set(obj, String, bits, gstr); GC_UNPROTECT(obj); GC_UNPROTECT(gstr);
  return obj;
}

static oop newSourceLocation(oop filename, long line, long column) {
  oop obj = newOops(SourceLocation); GC_PROTECT(obj);
  set(obj, SourceLocation, filename, filename);
  set(obj, SourceLocation, line, newLong(line));
  set(obj, SourceLocation, column, newLong(column)); GC_UNPROTECT(obj);
  return obj;
}

static oop getCurrentSourceLocation() {
  return newSourceLocation(current_filename, current_line, current_column);
}

static oop newPairWithSource(oop head, oop tail) {
  oop obj = newOops(Pair); GC_PROTECT(obj);
  set(obj, Pair, head, head);
  set(obj, Pair, tail, tail);
  set(obj, Pair, source, getCurrentSourceLocation()); GC_UNPROTECT(obj);
  return obj;
}

/* Source location utilities */
static void printSourceLocation(oop source) {
  if (!source) {
    printf("<no source>");
    return;
  }
  if (get(source, SourceLocation, filename)) {
    wprintf(L"%ls:", get(get(source, SourceLocation, filename), String, bits));
  } else {
    printf("<unknown>:");
  }
  printf("%ld:%ld",
    getLong(get(source, SourceLocation, line)),
    getLong(get(source, SourceLocation, column)));
}

static void debugTrace(oop obj, char *context) {
  printf("[DEBUG] %s at ", context);
  oop source = nil;
  if (is(Pair, obj)) source = get(obj, Pair, source);
  if (source) {
    printSourceLocation(source);
  } else {
    printf("<no location>");
  }
  printf("\n");
}

/* Test functions */
static oop test_arithmetic_with_debug(oop a, oop b) {
  /* Set current source location */
  current_filename = newString(L"arithmetic.l");
  current_line = 10;
  current_column = 5;

  oop result = newLong(getLong(a) + getLong(b));
  debugTrace(result, "arithmetic result");
  return result;
}

static oop test_pair_creation_with_debug() {
  /* Update source location */
  current_filename = newString(L"pairs.l");
  current_line = 25;
  current_column = 12;

  oop pair = newPairWithSource(newLong(42), newLong(17));
  debugTrace(pair, "pair creation");
  return pair;
}

int main(int argc, char **argv) {
  GC_init();
  setlocale(LC_ALL, "");

  printf("=== Source Location Tracking Demonstration ===\n\n");

  /* Test 1: Arithmetic with source tracking */
  printf("1. Arithmetic with source tracking:\n");
  oop result1 = test_arithmetic_with_debug(newLong(5), newLong(3));
  printf("   Result: %ld\n\n", getLong(result1));

  /* Test 2: Pair creation with source tracking */
  printf("2. Pair creation with source tracking:\n");
  oop result2 = test_pair_creation_with_debug();
  printf("   Pair: (%ld . %ld)\n", 
    getLong(get(result2, Pair, head)),
    getLong(get(result2, Pair, tail)));
  printf("   Source location: ");
  printSourceLocation(get(result2, Pair, source));
  printf("\n\n");

  /* Test 3: UTF-8 filenames */
  printf("3. UTF-8 filename support:\n");
  current_filename = newString(L"测试文件.l");
  current_line = 100;
  current_column = 1;
  oop utf8_pair = newPairWithSource(newString(L"Hello"), newString(L"世界"));
  printf("   UTF-8 pair source: ");
  printSourceLocation(get(utf8_pair, Pair, source));
  printf("\n");
  wprintf(L"   Content: %ls, %ls\n\n",
    get(get(utf8_pair, Pair, head), String, bits),
    get(get(utf8_pair, Pair, tail), String, bits));

  /* Test 4: GC preservation of source info */
  printf("4. GC preservation test:\n");
  printf("   Before GC - pair source: ");
  printSourceLocation(get(result2, Pair, source));
  printf("\n");
  GC_gcollect();
  printf("   After GC - pair source: ");
  printSourceLocation(get(result2, Pair, source));
  printf("\n\n");

  printf("=== Source Tracking Features Demonstrated ===\n");
  printf("✓ Automatic source location capture\n");
  printf("✓ Source-aware debugging traces\n");
  printf("✓ UTF-8 filename support\n");
  printf("✓ GC-safe source preservation\n");
  printf("✓ Ready for integration with error reporting\n");

  return 0;
}
