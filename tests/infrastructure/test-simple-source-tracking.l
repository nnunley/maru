#!/usr/bin/env eval
;;; test-simple-source-tracking.l -- Simple test for source location tracking

;;; Generate C program with source tracking (self-contained)
(define-function generate-source-tracking-demo ()
  (println "/* Source Location Tracking Demo - Generated by Maru */")
  (println)
  (println "#include <stdio.h>")
  (println "#include <stdlib.h>")
  (println "#include <string.h>")
  (println "#include <wchar.h>")
  (println "#include <locale.h>")
  (println)
  (println "/* Simple GC simulation */")
  (println "void *GC_malloc(size_t size) { return malloc(size); }")
  (println "void *GC_malloc_atomic(size_t size) { return malloc(size); }")
  (println "void GC_gcollect(void) { printf(\"[GC collection]\\n\"); }")
  (println)
  (println "/* GC Protection simulation */")
  (println "struct GC_StackRoot { void *root; struct GC_StackRoot *next; };")
  (println "static struct GC_StackRoot *gc_roots = NULL;")
  (println "void GC_push_root_simple(struct GC_StackRoot *sr) { sr->next = gc_roots; gc_roots = sr; }")
  (println "void GC_pop_root_simple(struct GC_StackRoot *sr) { if (gc_roots == sr) gc_roots = sr->next; }")
  (println "#define GC_PROTECT(V) struct GC_StackRoot _sr_##V; _sr_##V.root = (void *)&V; GC_push_root_simple(&_sr_##V)")
  (println "#define GC_UNPROTECT(V) GC_pop_root_simple(&_sr_##V)")
  (println)
  (println "/* Object system with source tracking */")
  (println "typedef union Object *oop;")
  (println "#define nil ((oop)0)")
  (println)
  (println "enum { Undefined, Long, String, Pair, SourceLocation };")
  (println)
  (println "struct Long { long bits; };")
  (println "struct String { oop size; wchar_t *bits; };")
  (println "struct Pair { oop head, tail, source; };")
  (println "struct SourceLocation { oop filename, line, column; };")
  (println)
  (println "union Object {")
  (println "  struct Long Long;")
  (println "  struct String String;")
  (println "  struct Pair Pair;")
  (println "  struct SourceLocation SourceLocation;")
  (println "};")
  (println)
  (println "/* Type system */")
  (println "typedef struct { int type; } *header_t;")
  (println "header_t obj2hdr(oop obj) { return (header_t)((char*)obj - sizeof(int)); }")
  (println "void setType(oop obj, int type) { obj2hdr(obj)->type = type; }")
  (println "int getType(oop obj) { return obj ? (((long)obj & 1) ? Long : obj2hdr(obj)->type) : Undefined; }")
  (println "#define is(TYPE, OBJ) ((OBJ) && (TYPE == getType(OBJ)))")
  (println "#define get(OBJ, TYPE, FIELD) ((OBJ)->TYPE.FIELD)")
  (println "#define set(OBJ, TYPE, FIELD, VALUE) ((OBJ)->TYPE.FIELD= (VALUE))")
  (println)
  (println "/* Object allocation */")
  (println "static oop _newBits(int type, size_t size) {")
  (println "  char *mem = GC_malloc_atomic(size + sizeof(int));")
  (println "  oop obj = (oop)(mem + sizeof(int));")
  (println "  setType(obj, type); return obj;")
  (println "}")
  (println "static oop _newOops(int type, size_t size) {")
  (println "  char *mem = GC_malloc(size + sizeof(int));")
  (println "  oop obj = (oop)(mem + sizeof(int));")
  (println "  setType(obj, type); return obj;")
  (println "}")
  (println "#define newBits(TYPE) _newBits(TYPE, sizeof(struct TYPE))")
  (println "#define newOops(TYPE) _newOops(TYPE, sizeof(struct TYPE))")
  (println)
  (println "/* Tagged integers */")
  (println "static inline oop newLong(long x) {")
  (println "  if ((x ^ (x << 1)) < 0) {")
  (println "    oop obj = newBits(Long);")
  (println "    set(obj, Long, bits, x);")
  (println "    return obj;")
  (println "  }")
  (println "  return ((oop)((x << 1) | 1));")
  (println "}")
  (println "static inline long getLong(oop x) {")
  (println "  if ((long)x & 1) return (long)x >> 1;")
  (println "  return get(x, Long, bits);")
  (println "}")
  (println)
  (println "/* Source location tracking */")
  (println "static oop current_filename = nil;")
  (println "static long current_line = 1;")
  (println "static long current_column = 1;")
  (println)
  (println "static oop newString(wchar_t *str) {")
  (println "  size_t len = wcslen(str);")
  (println "  wchar_t *gstr = (wchar_t *)_newBits(-1, sizeof(wchar_t) * (len + 1)); GC_PROTECT(gstr);")
  (println "  oop obj = newOops(String); GC_PROTECT(obj);")
  (println "  wcscpy(gstr, str);")
  (println "  set(obj, String, size, newLong(len));")
  (println "  set(obj, String, bits, gstr); GC_UNPROTECT(obj); GC_UNPROTECT(gstr);")
  (println "  return obj;")
  (println "}")
  (println)
  (println "static oop newSourceLocation(oop filename, long line, long column) {")
  (println "  oop obj = newOops(SourceLocation); GC_PROTECT(obj);")
  (println "  set(obj, SourceLocation, filename, filename);")
  (println "  set(obj, SourceLocation, line, newLong(line));")
  (println "  set(obj, SourceLocation, column, newLong(column)); GC_UNPROTECT(obj);")
  (println "  return obj;")
  (println "}")
  (println)
  (println "static oop getCurrentSourceLocation() {")
  (println "  return newSourceLocation(current_filename, current_line, current_column);")
  (println "}")
  (println)
  (println "static oop newPairWithSource(oop head, oop tail) {")
  (println "  oop obj = newOops(Pair); GC_PROTECT(obj);")
  (println "  set(obj, Pair, head, head);")
  (println "  set(obj, Pair, tail, tail);")
  (println "  set(obj, Pair, source, getCurrentSourceLocation()); GC_UNPROTECT(obj);")
  (println "  return obj;")
  (println "}")
  (println)
  (println "/* Source location utilities */")
  (println "static void printSourceLocation(oop source) {")
  (println "  if (!source) {")
  (println "    printf(\"<no source>\");")
  (println "    return;")
  (println "  }")
  (println "  if (get(source, SourceLocation, filename)) {")
  (println "    wprintf(L\"%ls:\", get(get(source, SourceLocation, filename), String, bits));")
  (println "  } else {")
  (println "    printf(\"<unknown>:\");")
  (println "  }")
  (println "  printf(\"%ld:%ld\",")
  (println "    getLong(get(source, SourceLocation, line)),")
  (println "    getLong(get(source, SourceLocation, column)));")
  (println "}")
  (println)
  (println "static void debugTrace(oop obj, char *context) {")
  (println "  printf(\"[DEBUG] %s at \", context);")
  (println "  oop source = nil;")
  (println "  if (is(Pair, obj)) source = get(obj, Pair, source);")
  (println "  if (source) {")
  (println "    printSourceLocation(source);")
  (println "  } else {")
  (println "    printf(\"<no location>\");")
  (println "  }")
  (println "  printf(\"\\n\");")
  (println "}")
  (println)
  (println "/* Test functions */")
  (println "static oop test_arithmetic_with_debug(oop a, oop b) {")
  (println "  /* Set current source location */")
  (println "  current_filename = newString(L\"arithmetic.l\");")
  (println "  current_line = 10;")
  (println "  current_column = 5;")
  (println)
  (println "  oop result = newLong(getLong(a) + getLong(b));")
  (println "  debugTrace(result, \"arithmetic result\");")
  (println "  return result;")
  (println "}")
  (println)
  (println "static oop test_pair_creation_with_debug() {")
  (println "  /* Update source location */")
  (println "  current_filename = newString(L\"pairs.l\");")
  (println "  current_line = 25;")
  (println "  current_column = 12;")
  (println)
  (println "  oop pair = newPairWithSource(newLong(42), newLong(17));")
  (println "  debugTrace(pair, \"pair creation\");")
  (println "  return pair;")
  (println "}")
  (println)
  (println "int main(int argc, char **argv) {")
  (println "  GC_init();")
  (println "  setlocale(LC_ALL, \"\");")
  (println)
  (println "  printf(\"=== Source Location Tracking Demonstration ===\\n\\n\");")
  (println)
  (println "  /* Test 1: Arithmetic with source tracking */")
  (println "  printf(\"1. Arithmetic with source tracking:\\n\");")
  (println "  oop result1 = test_arithmetic_with_debug(newLong(5), newLong(3));")
  (println "  printf(\"   Result: %ld\\n\\n\", getLong(result1));")
  (println)
  (println "  /* Test 2: Pair creation with source tracking */")
  (println "  printf(\"2. Pair creation with source tracking:\\n\");")
  (println "  oop result2 = test_pair_creation_with_debug();")
  (println "  printf(\"   Pair: (%ld . %ld)\\n\", ")
  (println "    getLong(get(result2, Pair, head)),")
  (println "    getLong(get(result2, Pair, tail)));")
  (println "  printf(\"   Source location: \");")
  (println "  printSourceLocation(get(result2, Pair, source));")
  (println "  printf(\"\\n\\n\");")
  (println)
  (println "  /* Test 3: UTF-8 filenames */")
  (println "  printf(\"3. UTF-8 filename support:\\n\");")
  (println "  current_filename = newString(L\"测试文件.l\");")
  (println "  current_line = 100;")
  (println "  current_column = 1;")
  (println "  oop utf8_pair = newPairWithSource(newString(L\"Hello\"), newString(L\"世界\"));")
  (println "  printf(\"   UTF-8 pair source: \");")
  (println "  printSourceLocation(get(utf8_pair, Pair, source));")
  (println "  printf(\"\\n\");")
  (println "  wprintf(L\"   Content: %ls, %ls\\n\\n\",")
  (println "    get(get(utf8_pair, Pair, head), String, bits),")
  (println "    get(get(utf8_pair, Pair, tail), String, bits));")
  (println)
  (println "  /* Test 4: GC preservation of source info */")
  (println "  printf(\"4. GC preservation test:\\n\");")
  (println "  printf(\"   Before GC - pair source: \");")
  (println "  printSourceLocation(get(result2, Pair, source));")
  (println "  printf(\"\\n\");")
  (println "  GC_gcollect();")
  (println "  printf(\"   After GC - pair source: \");")
  (println "  printSourceLocation(get(result2, Pair, source));")
  (println "  printf(\"\\n\\n\");")
  (println)
  (println "  printf(\"=== Source Tracking Features Demonstrated ===\\n\");")
  (println "  printf(\"✓ Automatic source location capture\\n\");")
  (println "  printf(\"✓ Source-aware debugging traces\\n\");")
  (println "  printf(\"✓ UTF-8 filename support\\n\");")
  (println "  printf(\"✓ GC-safe source preservation\\n\");")
  (println "  printf(\"✓ Ready for integration with error reporting\\n\");")
  (println)
  (println "  return 0;")
  (println "}"))

;;; Execute the generation
(generate-source-tracking-demo)