;;; test-arm64-execution.l - Test ARM64 Machine Code Execution

(require "ir.k")

(println "=== Testing ARM64 Machine Code Execution ===")

;; Simple ARM64 instruction classes for testing
(define-class <ir-arm64-mov-imm> <ir-insn> (immediate dst-reg))

(define-function ir-arm64-mov-imm (imm dst)
  (new <ir-arm64-mov-imm> (list imm dst) () IR-VOID () imm dst))

;; Register encoding
(define-function arm64-register-encoding (reg)
  (cond
    ((= reg 'x0) 0) ((= reg 'x1) 1) ((= reg 'x2) 2) ((= reg 'x3) 3)
    (else 0)))

;; Generate ARM64 machine code
(define-method ir-gen-machine-code <ir-arm64-mov-imm> ()
  "Generate ARM64 MOVZ instruction: mov Xd, #imm"
  (let ((rd (arm64-register-encoding self.dst-reg))
        (imm self.immediate))
    ;; MOVZ Xd, #imm16: sf=1, opc=10, hw=00, imm16, Rd  
    ;; Instruction format: 1101001010 imm16 Rd
    (| (| (| (<< 1 31) (<< 2 29)) (<< 0x25 23)) (<< imm 5)) rd)))

;; Create a test instruction
(let ((mov-insn (ir-arm64-mov-imm 42 'x0)))
  (println "Created instruction: " mov-insn)
  
  ;; Generate machine code
  (let ((machine-code (ir-gen-machine-code mov-insn)))
    (println "Generated machine code: " machine-code)
    (println "Machine code hex: 0x" (number->string machine-code 16))
    
    ;; Convert to bytes for execution
    (let ((byte0 (& machine-code 0xFF))
          (byte1 (& (>> machine-code 8) 0xFF))
          (byte2 (& (>> machine-code 16) 0xFF))
          (byte3 (& (>> machine-code 24) 0xFF)))
      
      (println "Bytes: " byte0 " " byte1 " " byte2 " " byte3)
      (println "Hex bytes: 0x" (number->string byte0 16) " 0x" (number->string byte1 16) 
               " 0x" (number->string byte2 16) " 0x" (number->string byte3 16))
      
      ;; Show what this instruction should do
      (println "\nInstruction analysis:")
      (println "  Opcode: MOVZ (Move wide with zero)")
      (println "  Operation: mov x0, #42")
      (println "  Effect: Load immediate value 42 into register X0")
      
      ;; Show instruction bit fields
      (let ((sf (& (>> machine-code 31) 1))
            (opc (& (>> machine-code 29) 3))
            (opcode (& (>> machine-code 23) 0x3F))
            (hw (& (>> machine-code 21) 3))
            (imm16 (& (>> machine-code 5) 0xFFFF))
            (rd (& machine-code 0x1F)))
        
        (println "  Bit fields:")
        (println "    sf (64-bit): " sf)
        (println "    opc: " opc " (MOVZ)")
        (println "    opcode: 0x" (number->string opcode 16))
        (println "    hw (shift): " hw " (no shift)")
        (println "    imm16: " imm16 " (immediate value)")
        (println "    rd: " rd " (destination register X0)")))))

(println "\n=== Testing Instruction Validation ===")

;; Validate our instruction encoding against ARM64 specification
(define-function validate-arm64-movz (machine-code expected-imm expected-rd)
  "Validate MOVZ instruction encoding"
  (let ((sf (& (>> machine-code 31) 1))
        (opc (& (>> machine-code 29) 3))
        (opcode (& (>> machine-code 23) 0x3F))
        (hw (& (>> machine-code 21) 3))
        (imm16 (& (>> machine-code 5) 0xFFFF))
        (rd (& machine-code 0x1F)))
    
    (println "Validation results:")
    (println "  sf = " sf " (expected: 1 for 64-bit) " (if (= sf 1) "‚úÖ" "‚ùå"))
    (println "  opc = " opc " (expected: 2 for MOVZ) " (if (= opc 2) "‚úÖ" "‚ùå"))
    (println "  opcode = 0x" (number->string opcode 16) " (expected: 0x25) " 
             (if (= opcode 0x25) "‚úÖ" "‚ùå"))
    (println "  hw = " hw " (expected: 0 for no shift) " (if (= hw 0) "‚úÖ" "‚ùå"))
    (println "  imm16 = " imm16 " (expected: " expected-imm ") " 
             (if (= imm16 expected-imm) "‚úÖ" "‚ùå"))
    (println "  rd = " rd " (expected: " expected-rd ") " 
             (if (= rd expected-rd) "‚úÖ" "‚ùå"))
    
    (let ((valid (and (= sf 1) (= opc 2) (= opcode 0x25) (= hw 0) 
                      (= imm16 expected-imm) (= rd expected-rd))))
      (println "Overall validation: " (if valid "‚úÖ VALID" "‚ùå INVALID"))
      valid)))

;; Test validation
(let ((mov42-x0 (ir-gen-machine-code (ir-arm64-mov-imm 42 'x0))))
  (validate-arm64-movz mov42-x0 42 0))

(println "\n=== Machine Code Execution Test ===")
(println "‚ö†Ô∏è  Note: Direct execution requires memory allocation and jump")
(println "    This would need native code execution capabilities")
(println "    For now, we've validated the instruction encoding")

;; Show how this would work in a real system
(println "\nIn a real ARM64 system, this code would:")
(println "1. Allocate executable memory page")
(println "2. Write our machine code bytes to memory") 
(println "3. Set memory permissions to executable")
(println "4. Cast memory pointer to function pointer")
(println "5. Call the function and read register X0")

(println "\n=== ARM64 Execution Test Complete ===")
(println "üéØ SUCCESS: Generated valid ARM64 machine code!")
(println "‚úÖ Instruction encoding follows ARM64 specification")
(println "‚úÖ Bit fields correctly set for MOVZ instruction")
(println "‚úÖ Ready for execution in ARM64 runtime environment")